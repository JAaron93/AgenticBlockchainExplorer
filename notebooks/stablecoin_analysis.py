"""
Stablecoin Analysis Notebook

A marimo notebook for analyzing stablecoin transaction data to determine
whether users primarily use stablecoins (USDC, USDT) for everyday transactions
or as a store of value.

This notebook consumes JSON export files generated by the blockchain explorer
data collection agents and provides interactive visualizations and statistical
analysis.
"""

import marimo

__generated_with = "0.10.9"
app = marimo.App(
    width="medium",
    app_title="Stablecoin Usage Analysis",
)


@app.cell
def imports():
    """Import required libraries and configure the notebook."""
    import marimo as mo
    import pandas as pd
    import altair as alt
    from decimal import Decimal
    from dataclasses import dataclass, field
    from pathlib import Path
    from typing import Optional
    from datetime import datetime
    import json

    return (
        mo,
        pd,
        alt,
        Decimal,
        dataclass,
        field,
        Path,
        Optional,
        datetime,
        json,
    )


@app.cell
def title(mo):
    """Display notebook title and description."""
    mo.md(
        """
        # Stablecoin Usage Analysis

        This notebook analyzes stablecoin transaction data collected by the
        blockchain explorer agents to determine whether users primarily use
        stablecoins (USDC, USDT) for **everyday transactions** or as a
        **store of value**.

        ## Features

        - Load and validate JSON export files from the data collection agents
        - Analyze activity type distribution (transactions vs store of value)
        - Compare usage patterns across different stablecoins (USDC vs USDT)
        - Analyze holder behavior and classification
        - Time series analysis of transaction patterns
        - Cross-chain comparison (Ethereum, BSC, Polygon)
        - Generate summary conclusions with confidence indicators

        ## Getting Started

        1. Select a JSON export file from the output directory below
        2. Or generate sample data to explore the analysis capabilities
        """
    )
    return


@app.cell
def config(Path):
    """Configuration constants."""
    # Default output directory for JSON exports
    OUTPUT_DIR = Path("output")

    # Supported stablecoins
    SUPPORTED_STABLECOINS = ["USDC", "USDT"]

    # Supported chains
    SUPPORTED_CHAINS = ["ethereum", "bsc", "polygon"]
    SUPPORTED_CHAIN_COUNT = 3

    # Activity types
    ACTIVITY_TYPES = ["transaction", "store_of_value", "other"]

    # Required fields for validation
    REQUIRED_TRANSACTION_FIELDS = [
        "transaction_hash", "timestamp", "amount",
        "stablecoin", "chain", "activity_type"
    ]

    return (
        OUTPUT_DIR,
        SUPPORTED_STABLECOINS,
        SUPPORTED_CHAINS,
        SUPPORTED_CHAIN_COUNT,
        ACTIVITY_TYPES,
        REQUIRED_TRANSACTION_FIELDS,
    )


@app.cell
def data_modules():
    """Import data loading and validation modules."""
    import sys
    from pathlib import Path

    # Add notebooks directory to path for imports
    notebooks_dir = Path(__file__).parent if '__file__' in dir() else Path('.')
    if str(notebooks_dir) not in sys.path:
        sys.path.insert(0, str(notebooks_dir))

    from stablecoin_validation import validate_schema
    from stablecoin_loader import LoadedData, load_json_file, load_json_data
    from stablecoin_analysis_functions import (
        ActivityBreakdown,
        analyze_activity_types,
    )

    return (
        validate_schema,
        LoadedData,
        load_json_file,
        load_json_data,
        ActivityBreakdown,
        analyze_activity_types,
    )


@app.cell
def file_selector_ui(mo, OUTPUT_DIR, Path):
    """File selector UI for choosing JSON export files."""
    # Get list of JSON files in output directory
    json_files = []
    if OUTPUT_DIR.exists():
        json_files = sorted([
            f.name for f in OUTPUT_DIR.iterdir()
            if f.suffix == '.json'
        ], reverse=True)

    # Create file selector dropdown
    file_options = {"-- Select a file --": None}
    file_options.update({f: str(OUTPUT_DIR / f) for f in json_files})

    file_selector = mo.ui.dropdown(
        options=file_options,
        label="Select JSON Export File",
        value=None,
    )

    # Sample data toggle
    use_sample_data = mo.ui.checkbox(
        label="Use sample data instead",
        value=False,
    )

    mo.md(f"""
    ## Data Source

    Select a JSON export file from the output directory, or use sample data for testing.

    {file_selector}

    {use_sample_data}

    **Available files:** {len(json_files)} JSON file(s) found in `{OUTPUT_DIR}`
    """)

    return file_selector, use_sample_data, json_files


@app.cell
def load_data_cell(
    mo,
    file_selector,
    use_sample_data,
    load_json_file,
):
    """Load data based on user selection."""
    loaded_data = None
    load_error = None

    if use_sample_data.value:
        # Sample data will be implemented in task 8
        mo.md("""
        âš ï¸ **Sample data generation not yet implemented.**

        Please select a JSON file from the output directory.
        """)
    elif file_selector.value:
        try:
            loaded_data = load_json_file(file_selector.value)
        except FileNotFoundError as e:
            load_error = f"âŒ **File not found:** {e}"
        except ValueError as e:
            load_error = f"âŒ **Validation error:**\n\n```\n{e}\n```"
        except Exception as e:
            load_error = f"âŒ **Error loading file:** {type(e).__name__}: {e}"

    return loaded_data, load_error


@app.cell
def display_metadata(mo, loaded_data, load_error):
    """Display metadata after file selection."""
    if load_error:
        mo.md(load_error)
    elif loaded_data:
        meta = loaded_data.metadata
        tx_count = len(loaded_data.transactions_df)
        holder_count = len(loaded_data.holders_df)

        sample_indicator = ""
        if loaded_data.is_sample_data:
            sample_indicator = "\n\nâš ï¸ **Note:** This analysis is based on synthetic sample data, not real blockchain data."

        error_warnings = ""
        if loaded_data.errors:
            error_warnings = f"\n\nâš ï¸ **Data Quality Warnings:** {len(loaded_data.errors)} error(s) during collection"

        mo.md(f"""
        ## Data Loaded Successfully âœ“

        | Field | Value |
        |-------|-------|
        | **Run ID** | `{meta.get('run_id', 'N/A')}` |
        | **Collection Time** | {meta.get('collection_timestamp', 'N/A')} |
        | **Agent Version** | {meta.get('agent_version', 'N/A')} |
        | **Explorers Queried** | {', '.join(meta.get('explorers_queried', []))} |
        | **Total Records** | {meta.get('total_records', 'N/A')} |
        | **Transactions Loaded** | {tx_count} |
        | **Holders Loaded** | {holder_count} |
        {sample_indicator}{error_warnings}
        """)
    else:
        mo.md("""
        ðŸ‘† **Select a JSON file above to begin analysis.**
        """)

    return


@app.cell
def activity_analysis_cell(loaded_data, analyze_activity_types):
    """Analyze activity type distribution."""
    activity_breakdown = None

    if loaded_data is not None:
        activity_breakdown = analyze_activity_types(
            loaded_data.transactions_df
        )

    return (activity_breakdown,)


@app.cell
def activity_breakdown_display(mo, loaded_data, activity_breakdown, Decimal):
    """Display activity type breakdown with visualizations."""
    if loaded_data is None or activity_breakdown is None:
        return

    def format_currency(amount: Decimal) -> str:
        """Format amount with currency notation."""
        if amount >= Decimal("1000000000"):
            return f"${float(amount) / 1e9:.2f}B"
        elif amount >= Decimal("1000000"):
            return f"${float(amount) / 1e6:.2f}M"
        elif amount >= Decimal("1000"):
            return f"${float(amount) / 1e3:.2f}K"
        else:
            return f"${float(amount):.2f}"

    # Build counts table
    counts_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        count = activity_breakdown.counts.get(at, 0)
        pct = activity_breakdown.percentages.get(at, 0.0)
        counts_rows.append(f"| {at} | {count:,} | {pct:.1f}% |")

    total_count = sum(activity_breakdown.counts.values())
    counts_table = "\n".join(counts_rows)

    # Build volumes table
    volumes_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        vol = activity_breakdown.volumes.get(at, Decimal("0"))
        vol_pct = activity_breakdown.volume_percentages.get(at, 0.0)
        volumes_rows.append(
            f"| {at} | {format_currency(vol)} | {vol_pct:.1f}% |"
        )

    total_volume = sum(activity_breakdown.volumes.values())
    volumes_table = "\n".join(volumes_rows)

    mo.md(f"""
    ## Activity Type Analysis

    ### Transaction Counts by Activity Type

    | Activity Type | Count | Percentage |
    |---------------|-------|------------|
    {counts_table}
    | **Total** | **{total_count:,}** | **100.0%** |

    ### Transaction Volume by Activity Type

    | Activity Type | Volume | Percentage |
    |---------------|--------|------------|
    {volumes_table}
    | **Total** | **{format_currency(total_volume)}** | **100.0%** |
    """)

    return (format_currency,)


@app.cell
def activity_pie_chart(mo, alt, pd, loaded_data, activity_breakdown):
    """Create pie chart for activity type distribution."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Prepare data for pie chart
    pie_data = pd.DataFrame([
        {
            "activity_type": at,
            "count": activity_breakdown.counts.get(at, 0),
            "percentage": activity_breakdown.percentages.get(at, 0.0),
        }
        for at in ["transaction", "store_of_value", "other"]
        if activity_breakdown.counts.get(at, 0) > 0
    ])

    if pie_data.empty:
        mo.md("*No transaction data available for pie chart.*")
        return

    # Create pie chart using Altair
    pie_chart = alt.Chart(pie_data).mark_arc(innerRadius=50).encode(
        theta=alt.Theta(field="count", type="quantitative"),
        color=alt.Color(
            field="activity_type",
            type="nominal",
            scale=alt.Scale(
                domain=["transaction", "store_of_value", "other"],
                range=["#4C78A8", "#F58518", "#72B7B2"]
            ),
            legend=alt.Legend(title="Activity Type")
        ),
        tooltip=[
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("count:Q", title="Count", format=","),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Transaction Distribution by Activity Type",
        width=300,
        height=300
    )

    mo.md("### Activity Type Distribution (Pie Chart)")
    return (pie_chart,)


@app.cell
def display_pie_chart(mo, loaded_data, activity_breakdown, pie_chart):
    """Display the pie chart."""
    if loaded_data is None or activity_breakdown is None:
        return

    try:
        mo.ui.altair_chart(pie_chart)
    except Exception:
        # Fallback if altair_chart not available
        pie_chart
    return


@app.cell
def activity_volume_bar_chart(
    mo, alt, pd, loaded_data, activity_breakdown, Decimal
):
    """Create bar chart for volume by activity type."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Prepare data for bar chart
    bar_data = pd.DataFrame([
        {
            "activity_type": at,
            "volume": float(activity_breakdown.volumes.get(at, Decimal("0"))),
            "volume_pct": activity_breakdown.volume_percentages.get(at, 0.0),
        }
        for at in ["transaction", "store_of_value", "other"]
    ])

    if bar_data["volume"].sum() == 0:
        mo.md("*No volume data available for bar chart.*")
        return

    # Create bar chart using Altair
    bar_chart = alt.Chart(bar_data).mark_bar().encode(
        x=alt.X(
            "activity_type:N",
            title="Activity Type",
            sort=["transaction", "store_of_value", "other"]
        ),
        y=alt.Y("volume:Q", title="Volume (USD)"),
        color=alt.Color(
            "activity_type:N",
            scale=alt.Scale(
                domain=["transaction", "store_of_value", "other"],
                range=["#4C78A8", "#F58518", "#72B7B2"]
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("volume:Q", title="Volume", format=",.2f"),
            alt.Tooltip("volume_pct:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Transaction Volume by Activity Type",
        width=400,
        height=300
    )

    mo.md("### Volume by Activity Type (Bar Chart)")
    return (bar_chart,)


@app.cell
def display_bar_chart(mo, loaded_data, activity_breakdown, bar_chart):
    """Display the bar chart."""
    if loaded_data is None or activity_breakdown is None:
        return

    try:
        mo.ui.altair_chart(bar_chart)
    except Exception:
        # Fallback if altair_chart not available
        bar_chart
    return


if __name__ == "__main__":
    app.run()
