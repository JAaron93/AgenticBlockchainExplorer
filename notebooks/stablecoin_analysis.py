"""
Stablecoin Analysis Notebook

A marimo notebook for analyzing stablecoin transaction data to determine
whether users primarily use stablecoins (USDC, USDT) for everyday transactions
or as a store of value.

This notebook consumes JSON export files generated by the blockchain explorer
data collection agents and provides interactive visualizations and statistical
analysis.
"""

import marimo

__generated_with = "0.10.9"
app = marimo.App(
    width="medium",
    app_title="Stablecoin Usage Analysis",
)


@app.cell
def imports():
    """Import required libraries and configure the notebook."""
    import marimo as mo
    import pandas as pd
    import altair as alt
    from decimal import Decimal
    from dataclasses import dataclass, field
    from pathlib import Path
    from typing import Optional
    from datetime import datetime
    import json

    return (
        mo,
        pd,
        alt,
        Decimal,
        dataclass,
        field,
        Path,
        Optional,
        datetime,
        json,
    )


@app.cell
def title(mo):
    """Display notebook title and description."""
    mo.md(
        """
        # Stablecoin Usage Analysis

        This notebook analyzes stablecoin transaction data collected by the
        blockchain explorer agents to determine whether users primarily use
        stablecoins (USDC, USDT) for **everyday transactions** or as a
        **store of value**.

        ## Features

        - Load and validate JSON export files from the data collection agents
        - Analyze activity type distribution (transactions vs store of value)
        - Compare usage patterns across different stablecoins (USDC vs USDT)
        - Analyze holder behavior and classification
        - Time series analysis of transaction patterns
        - Cross-chain comparison (Ethereum, BSC, Polygon)
        - Generate summary conclusions with confidence indicators

        ## Getting Started

        1. Select a JSON export file from the output directory below
        2. Or generate sample data to explore the analysis capabilities
        """
    )
    return


@app.cell
def config(Path):
    """Configuration constants."""
    # Default output directory for JSON exports
    OUTPUT_DIR = Path("output")

    # Supported stablecoins
    SUPPORTED_STABLECOINS = ["USDC", "USDT"]

    # Supported chains
    SUPPORTED_CHAINS = ["ethereum", "bsc", "polygon"]
    SUPPORTED_CHAIN_COUNT = 3

    # Activity types
    ACTIVITY_TYPES = ["transaction", "store_of_value", "other"]

    # Required fields for validation
    REQUIRED_TRANSACTION_FIELDS = [
        "transaction_hash", "timestamp", "amount",
        "stablecoin", "chain", "activity_type"
    ]

    return (
        OUTPUT_DIR,
        SUPPORTED_STABLECOINS,
        SUPPORTED_CHAINS,
        SUPPORTED_CHAIN_COUNT,
        ACTIVITY_TYPES,
        REQUIRED_TRANSACTION_FIELDS,
    )


@app.cell
def utility_functions(Decimal):
    """Shared utility functions for the notebook."""

    def format_currency(amount: Decimal) -> str:
        """Format amount with currency notation."""
        if amount >= Decimal("1000000000"):
            return f"${float(amount) / 1e9:.2f}B"
        elif amount >= Decimal("1000000"):
            return f"${float(amount) / 1e6:.2f}M"
        elif amount >= Decimal("1000"):
            return f"${float(amount) / 1e3:.2f}K"
        else:
            return f"${float(amount):.2f}"

    return (format_currency,)


@app.cell
def data_modules():
    """Import data loading and validation modules."""
    import sys
    from pathlib import Path

    # Add notebooks directory to path for imports
    notebooks_dir = Path(__file__).parent if '__file__' in dir() else Path('.')
    if str(notebooks_dir) not in sys.path:
        sys.path.insert(0, str(notebooks_dir))

    from stablecoin_validation import validate_schema
    from stablecoin_loader import LoadedData, load_json_file, load_json_data
    from stablecoin_analysis_functions import (
        ActivityBreakdown,
        analyze_activity_types,
        StablecoinMetrics,
        StablecoinComparison,
        analyze_by_stablecoin,
        calculate_average_transaction_size,
        HolderMetrics,
        TopHolder,
        analyze_holders,
        get_top_holders,
    )

    return (
        validate_schema,
        LoadedData,
        load_json_file,
        load_json_data,
        ActivityBreakdown,
        analyze_activity_types,
        StablecoinMetrics,
        StablecoinComparison,
        analyze_by_stablecoin,
        calculate_average_transaction_size,
        HolderMetrics,
        TopHolder,
        analyze_holders,
        get_top_holders,
    )


@app.cell
def file_selector_ui(mo, OUTPUT_DIR, Path):
    """File selector UI for choosing JSON export files."""
    # Get list of JSON files in output directory
    json_files = []
    if OUTPUT_DIR.exists():
        json_files = sorted([
            f.name for f in OUTPUT_DIR.iterdir()
            if f.suffix == '.json'
        ], reverse=True)

    # Create file selector dropdown
    file_options = {"-- Select a file --": None}
    file_options.update({f: str(OUTPUT_DIR / f) for f in json_files})

    file_selector = mo.ui.dropdown(
        options=file_options,
        label="Select JSON Export File",
        value=None,
    )

    # Sample data toggle
    use_sample_data = mo.ui.checkbox(
        label="Use sample data instead",
        value=False,
    )

    mo.md(f"""
    ## Data Source

    Select a JSON export file from the output directory, or use sample data for testing.

    {file_selector}

    {use_sample_data}

    **Available files:** {len(json_files)} JSON file(s) found in `{OUTPUT_DIR}`
    """)

    return file_selector, use_sample_data, json_files


@app.cell
def load_data_cell(
    mo,
    file_selector,
    use_sample_data,
    load_json_file,
):
    """Load data based on user selection."""
    loaded_data = None
    load_error = None

    if use_sample_data.value:
        # Sample data will be implemented in task 8
        mo.md("""
        âš ï¸ **Sample data generation not yet implemented.**

        Please select a JSON file from the output directory.
        """)
    elif file_selector.value:
        try:
            loaded_data = load_json_file(file_selector.value)
        except FileNotFoundError as e:
            load_error = f"âŒ **File not found:** {e}"
        except ValueError as e:
            load_error = f"âŒ **Validation error:**\n\n```\n{e}\n```"
        except Exception as e:
            load_error = f"âŒ **Error loading file:** {type(e).__name__}: {e}"

    return loaded_data, load_error


@app.cell
def display_metadata(mo, loaded_data, load_error):
    """Display metadata after file selection."""
    if load_error:
        mo.md(load_error)
    elif loaded_data:
        meta = loaded_data.metadata
        tx_count = len(loaded_data.transactions_df)
        holder_count = len(loaded_data.holders_df)

        sample_indicator = ""
        if loaded_data.is_sample_data:
            sample_indicator = "\n\nâš ï¸ **Note:** This analysis is based on synthetic sample data, not real blockchain data."

        error_warnings = ""
        if loaded_data.errors:
            error_warnings = f"\n\nâš ï¸ **Data Quality Warnings:** {len(loaded_data.errors)} error(s) during collection"

        mo.md(f"""
        ## Data Loaded Successfully âœ“

        | Field | Value |
        |-------|-------|
        | **Run ID** | `{meta.get('run_id', 'N/A')}` |
        | **Collection Time** | {meta.get('collection_timestamp', 'N/A')} |
        | **Agent Version** | {meta.get('agent_version', 'N/A')} |
        | **Explorers Queried** | {', '.join(meta.get('explorers_queried', []))} |
        | **Total Records** | {meta.get('total_records', 'N/A')} |
        | **Transactions Loaded** | {tx_count} |
        | **Holders Loaded** | {holder_count} |
        {sample_indicator}{error_warnings}
        """)
    else:
        mo.md("""
        ðŸ‘† **Select a JSON file above to begin analysis.**
        """)

    return


@app.cell
def activity_analysis_cell(loaded_data, analyze_activity_types):
    """Analyze activity type distribution."""
    activity_breakdown = None

    if loaded_data is not None:
        activity_breakdown = analyze_activity_types(
            loaded_data.transactions_df
        )

    return (activity_breakdown,)


@app.cell
def activity_breakdown_display(
    mo, loaded_data, activity_breakdown, Decimal, format_currency
):
    """Display activity type breakdown with visualizations."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Build counts table
    counts_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        count = activity_breakdown.counts.get(at, 0)
        pct = activity_breakdown.percentages.get(at, 0.0)
        counts_rows.append(f"| {at} | {count:,} | {pct:.1f}% |")

    total_count = sum(activity_breakdown.counts.values())
    counts_table = "\n".join(counts_rows)

    # Build volumes table
    volumes_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        vol = activity_breakdown.volumes.get(at, Decimal("0"))
        vol_pct = activity_breakdown.volume_percentages.get(at, 0.0)
        volumes_rows.append(
            f"| {at} | {format_currency(vol)} | {vol_pct:.1f}% |"
        )

    total_volume = sum(activity_breakdown.volumes.values())
    volumes_table = "\n".join(volumes_rows)

    mo.md(f"""
    ## Activity Type Analysis

    ### Transaction Counts by Activity Type

    | Activity Type | Count | Percentage |
    |---------------|-------|------------|
    {counts_table}
    | **Total** | **{total_count:,}** | **100.0%** |

    ### Transaction Volume by Activity Type

    | Activity Type | Volume | Percentage |
    |---------------|--------|------------|
    {volumes_table}
    | **Total** | **{format_currency(total_volume)}** | **100.0%** |
    """)

    return


@app.cell
def activity_pie_chart(mo, alt, pd, loaded_data, activity_breakdown):
    """Create pie chart for activity type distribution."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Prepare data for pie chart
    pie_data = pd.DataFrame([
        {
            "activity_type": at,
            "count": activity_breakdown.counts.get(at, 0),
            "percentage": activity_breakdown.percentages.get(at, 0.0),
        }
        for at in ["transaction", "store_of_value", "other"]
        if activity_breakdown.counts.get(at, 0) > 0
    ])

    if pie_data.empty:
        return (None,)

    # Create pie chart using Altair
    pie_chart = alt.Chart(pie_data).mark_arc(innerRadius=50).encode(
        theta=alt.Theta(field="count", type="quantitative"),
        color=alt.Color(
            field="activity_type",
            type="nominal",
            scale=alt.Scale(
                domain=["transaction", "store_of_value", "other"],
                range=["#4C78A8", "#F58518", "#72B7B2"]
            ),
            legend=alt.Legend(title="Activity Type")
        ),
        tooltip=[
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("count:Q", title="Count", format=","),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Transaction Distribution by Activity Type",
        width=300,
        height=300
    )

    mo.md("### Activity Type Distribution (Pie Chart)")
    return (pie_chart,)


@app.cell
def display_pie_chart(mo, loaded_data, activity_breakdown, pie_chart):
    """Display the pie chart."""
    if loaded_data is None or activity_breakdown is None or pie_chart is None:
        return

    try:
        return mo.ui.altair_chart(pie_chart)
    except Exception:
        # Fallback if altair_chart not available
        return pie_chart


@app.cell
def activity_volume_bar_chart(
    mo, alt, pd, loaded_data, activity_breakdown, Decimal
):
    """Create bar chart for volume by activity type."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Prepare data for bar chart
    bar_data = pd.DataFrame([
        {
            "activity_type": at,
            "volume": float(activity_breakdown.volumes.get(at, Decimal("0"))),
            "volume_pct": activity_breakdown.volume_percentages.get(at, 0.0),
        }
        for at in ["transaction", "store_of_value", "other"]
    ])

    if bar_data["volume"].sum() == 0:
        return (None,)
    # Create bar chart using Altair
    bar_chart = alt.Chart(bar_data).mark_bar().encode(
        x=alt.X(
            "activity_type:N",
            title="Activity Type",
            sort=["transaction", "store_of_value", "other"]
        ),
        y=alt.Y("volume:Q", title="Volume (USD)"),
        color=alt.Color(
            "activity_type:N",
            scale=alt.Scale(
                domain=["transaction", "store_of_value", "other"],
                range=["#4C78A8", "#F58518", "#72B7B2"]
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("volume:Q", title="Volume", format=",.2f"),
            alt.Tooltip("volume_pct:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Transaction Volume by Activity Type",
        width=400,
        height=300
    )

    mo.md("### Volume by Activity Type (Bar Chart)")
    return (bar_chart,)


@app.cell
def display_bar_chart(mo, loaded_data, activity_breakdown, bar_chart):
    """Display the bar chart."""
    if loaded_data is None or activity_breakdown is None or bar_chart is None:
        return

    try:
        return mo.ui.altair_chart(bar_chart)
    except Exception:
        # Fallback if altair_chart not available
        return bar_chart


# =============================================================================
# Stablecoin Comparison Analysis (Task 4)
# =============================================================================


@app.cell
def stablecoin_analysis_cell(loaded_data, analyze_by_stablecoin):
    """Analyze transactions grouped by stablecoin type."""
    stablecoin_comparison = None

    if loaded_data is not None:
        stablecoin_comparison = analyze_by_stablecoin(
            loaded_data.transactions_df,
            loaded_data.holders_df,
        )

    return (stablecoin_comparison,)


@app.cell
def stablecoin_comparison_display(
    mo, loaded_data, stablecoin_comparison, format_currency
):
    """Display stablecoin comparison metrics."""
    if loaded_data is None or stablecoin_comparison is None:
        return

    # Build comparison table
    rows = []
    for coin in ["USDC", "USDT"]:
        metrics = stablecoin_comparison.by_stablecoin.get(coin)
        if metrics:
            rows.append(
                f"| {coin} | {metrics.transaction_count:,} | "
                f"{format_currency(metrics.total_volume)} | "
                f"{format_currency(metrics.avg_transaction_size)} | "
                f"{metrics.sov_ratio * 100:.1f}% |"
            )

    table_rows = "\n".join(rows)

    # Build activity distribution comparison
    activity_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        usdc_metrics = stablecoin_comparison.by_stablecoin.get("USDC")
        usdt_metrics = stablecoin_comparison.by_stablecoin.get("USDT")
        usdc_pct = usdc_metrics.activity_distribution.get(at, 0.0) if usdc_metrics else 0.0
        usdt_pct = usdt_metrics.activity_distribution.get(at, 0.0) if usdt_metrics else 0.0
        activity_rows.append(f"| {at} | {usdc_pct:.1f}% | {usdt_pct:.1f}% |")

    activity_table = "\n".join(activity_rows)

    mo.md(f"""
    ## Stablecoin Comparison Analysis

    ### Overview by Stablecoin

    | Stablecoin | Transactions | Total Volume | Avg Tx Size | SoV Ratio |
    |------------|--------------|--------------|-------------|-----------|
    {table_rows}

    ### Activity Type Distribution by Stablecoin

    | Activity Type | USDC | USDT |
    |---------------|------|------|
    {activity_table}

    **Note:** SoV Ratio = percentage of holders classified as store-of-value
    """)

    return


@app.cell
def stablecoin_grouped_bar_chart(
    mo, alt, pd, loaded_data, stablecoin_comparison, Decimal
):
    """Create grouped bar chart comparing USDC vs USDT activity distribution."""
    if loaded_data is None or stablecoin_comparison is None:
        return

    # Prepare data for grouped bar chart
    chart_data = []
    for coin in ["USDC", "USDT"]:
        metrics = stablecoin_comparison.by_stablecoin.get(coin)
        if metrics:
            for at in ["transaction", "store_of_value", "other"]:
                pct = metrics.activity_distribution.get(at, 0.0)
                chart_data.append({
                    "stablecoin": coin,
                    "activity_type": at,
                    "percentage": pct,
                })

    if not chart_data:
        return (None,)

    chart_df = pd.DataFrame(chart_data)

    # Create grouped bar chart
    grouped_chart = alt.Chart(chart_df).mark_bar().encode(
        x=alt.X(
            "activity_type:N",
            title="Activity Type",
            sort=["transaction", "store_of_value", "other"],
            axis=alt.Axis(labelAngle=-45)
        ),
        y=alt.Y("percentage:Q", title="Percentage (%)"),
        color=alt.Color(
            "stablecoin:N",
            scale=alt.Scale(
                domain=["USDC", "USDT"],
                range=["#2775CA", "#26A17B"]  # USDC blue, USDT green
            ),
            legend=alt.Legend(title="Stablecoin")
        ),
        xOffset="stablecoin:N",
        tooltip=[
            alt.Tooltip("stablecoin:N", title="Stablecoin"),
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Activity Type Distribution: USDC vs USDT",
        width=400,
        height=300
    )

    mo.md("### Activity Distribution Comparison (Grouped Bar Chart)")
    return (grouped_chart,)


@app.cell
def display_grouped_chart(mo, loaded_data, stablecoin_comparison, grouped_chart):
    """Display the grouped bar chart."""
    if loaded_data is None or stablecoin_comparison is None:
        return
    if grouped_chart is None:
        return

    try:
        return mo.ui.altair_chart(grouped_chart)
    except Exception:
        return grouped_chart


@app.cell
def avg_tx_size_comparison_chart(
    mo, alt, pd, loaded_data, stablecoin_comparison, Decimal
):
    """Create bar chart comparing average transaction size by stablecoin."""
    if loaded_data is None or stablecoin_comparison is None:
        return

    # Prepare data for average transaction size comparison
    avg_data = []
    for coin in ["USDC", "USDT"]:
        metrics = stablecoin_comparison.by_stablecoin.get(coin)
        if metrics and metrics.transaction_count > 0:
            avg_data.append({
                "stablecoin": coin,
                "avg_tx_size": float(metrics.avg_transaction_size),
            })

    if not avg_data:
        return (None,)

    avg_df = pd.DataFrame(avg_data)

    # Create bar chart for average transaction size
    avg_chart = alt.Chart(avg_df).mark_bar().encode(
        x=alt.X("stablecoin:N", title="Stablecoin"),
        y=alt.Y("avg_tx_size:Q", title="Average Transaction Size (USD)"),
        color=alt.Color(
            "stablecoin:N",
            scale=alt.Scale(
                domain=["USDC", "USDT"],
                range=["#2775CA", "#26A17B"]
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip("stablecoin:N", title="Stablecoin"),
            alt.Tooltip("avg_tx_size:Q", title="Avg Tx Size", format=",.2f"),
        ]
    ).properties(
        title="Average Transaction Size: USDC vs USDT",
        width=300,
        height=300
    )

    mo.md("### Average Transaction Size Comparison")
    return (avg_chart,)


@app.cell
def display_avg_chart(mo, loaded_data, stablecoin_comparison, avg_chart):
    """Display the average transaction size chart."""
    if loaded_data is None or stablecoin_comparison is None:
        return
    if avg_chart is None:
        return

    try:
        return mo.ui.altair_chart(avg_chart)
    except Exception:
        return avg_chart


# =============================================================================
# Holder Behavior Analysis (Task 5)
# =============================================================================


@app.cell
def holder_analysis_cell(loaded_data, analyze_holders, get_top_holders):
    """Analyze holder behavior patterns."""
    holder_metrics = None
    top_holders = None

    if loaded_data is not None and not loaded_data.holders_df.empty:
        holder_metrics = analyze_holders(
            loaded_data.holders_df,
            loaded_data.transactions_df,
        )
        top_holders = get_top_holders(loaded_data.holders_df, n=10)

    return holder_metrics, top_holders


@app.cell
def holder_metrics_display(
    mo, loaded_data, holder_metrics, format_currency
):
    """Display holder behavior metrics."""
    if loaded_data is None or holder_metrics is None:
        return

    mo.md(f"""
    ## Holder Behavior Analysis

    ### Holder Classification Summary

    | Metric | Value |
    |--------|-------|
    | **Total Holders** | {holder_metrics.total_holders:,} |
    | **Store of Value Holders** | {holder_metrics.sov_count:,} |
    | **Active Transactors** | {holder_metrics.total_holders - holder_metrics.sov_count:,} |
    | **SoV Percentage** | {holder_metrics.sov_percentage:.1f}% |

    ### Balance Analysis

    | Metric | Store of Value | Active Transactors |
    |--------|----------------|-------------------|
    | **Average Balance** | {format_currency(holder_metrics.avg_balance_sov)} | {format_currency(holder_metrics.avg_balance_active)} |

    ### Holding Period (Store of Value Holders)

    | Metric | Value |
    |--------|-------|
    | **Average Holding Period** | {holder_metrics.avg_holding_period_days:.1f} days |
    | **Median Holding Period** | {holder_metrics.median_holding_period_days:.1f} days |
    """)

    return


@app.cell
def holder_balance_histogram(mo, alt, pd, loaded_data, Decimal):
    """Create histogram of holder balances segmented by SoV status."""
    if loaded_data is None or loaded_data.holders_df.empty:
        return (None,)

    # Prepare data for histogram
    df = loaded_data.holders_df.copy()

    # Convert balance to float for visualization
    df["balance_float"] = df["balance"].apply(
        lambda x: float(x) if isinstance(x, Decimal) else float(str(x)) if x else 0.0
    )

    # Create SoV status label
    df["sov_status"] = df["is_store_of_value"].apply(
        lambda x: "Store of Value" if x else "Active Transactor"
    )

    # Filter out zero balances for better visualization
    df_nonzero = df[df["balance_float"] > 0]

    if df_nonzero.empty:
        return (None,)

    # Create histogram with log scale for better distribution visibility
    histogram = alt.Chart(df_nonzero).mark_bar(opacity=0.7).encode(
        x=alt.X(
            "balance_float:Q",
            bin=alt.Bin(maxbins=30),
            title="Balance (USD)",
            scale=alt.Scale(type="log")
        ),
        y=alt.Y("count():Q", title="Number of Holders"),
        color=alt.Color(
            "sov_status:N",
            scale=alt.Scale(
                domain=["Store of Value", "Active Transactor"],
                range=["#F58518", "#4C78A8"]
            ),
            legend=alt.Legend(title="Holder Type")
        ),
        tooltip=[
            alt.Tooltip("sov_status:N", title="Holder Type"),
            alt.Tooltip("count():Q", title="Count"),
        ]
    ).properties(
        title="Distribution of Holder Balances by Classification",
        width=500,
        height=300
    )

    mo.md("### Holder Balance Distribution (Histogram)")
    return (histogram,)


@app.cell
def display_holder_histogram(mo, loaded_data, histogram):
    """Display the holder balance histogram."""
    if loaded_data is None or histogram is None:
        return

    try:
        return mo.ui.altair_chart(histogram)
    except Exception:
        return histogram


@app.cell
def top_holders_table(mo, loaded_data, top_holders, format_currency):
    """Display top 10 holders table with classifications."""
    if loaded_data is None or not top_holders:
        return

    # Build table rows
    rows = []
    for i, holder in enumerate(top_holders, 1):
        # Mask address for privacy (show first 6 and last 4 chars)
        addr = holder.address
        masked_addr = f"{addr[:6]}...{addr[-4:]}" if len(addr) > 10 else addr

        sov_status = "âœ“ SoV" if holder.is_store_of_value else "Active"

        rows.append(
            f"| {i} | `{masked_addr}` | {format_currency(holder.balance)} | "
            f"{holder.stablecoin} | {holder.chain} | {sov_status} |"
        )

    table_rows = "\n".join(rows)

    mo.md(f"""
    ### Top 10 Holders by Balance

    | Rank | Address | Balance | Stablecoin | Chain | Classification |
    |------|---------|---------|------------|-------|----------------|
    {table_rows}

    **Note:** Addresses are masked for privacy (showing first 6 and last 4 characters).
    """)

    return


@app.cell
def holder_sov_pie_chart(mo, alt, pd, loaded_data, holder_metrics):
    """Create pie chart for holder SoV classification distribution."""
    if loaded_data is None or holder_metrics is None:
        return (None,)

    if holder_metrics.total_holders == 0:
        return (None,)

    # Prepare data for pie chart
    pie_data = pd.DataFrame([
        {
            "classification": "Store of Value",
            "count": holder_metrics.sov_count,
            "percentage": holder_metrics.sov_percentage,
        },
        {
            "classification": "Active Transactor",
            "count": holder_metrics.total_holders - holder_metrics.sov_count,
            "percentage": 100.0 - holder_metrics.sov_percentage,
        }
    ])

    # Filter out zero counts
    pie_data = pie_data[pie_data["count"] > 0]

    if pie_data.empty:
        return (None,)

    # Create pie chart
    sov_pie = alt.Chart(pie_data).mark_arc(innerRadius=50).encode(
        theta=alt.Theta(field="count", type="quantitative"),
        color=alt.Color(
            field="classification",
            type="nominal",
            scale=alt.Scale(
                domain=["Store of Value", "Active Transactor"],
                range=["#F58518", "#4C78A8"]
            ),
            legend=alt.Legend(title="Classification")
        ),
        tooltip=[
            alt.Tooltip("classification:N", title="Classification"),
            alt.Tooltip("count:Q", title="Count", format=","),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Holder Classification Distribution",
        width=300,
        height=300
    )

    mo.md("### Holder Classification (Pie Chart)")
    return (sov_pie,)


@app.cell
def display_sov_pie(mo, loaded_data, holder_metrics, sov_pie):
    """Display the holder SoV pie chart."""
    if loaded_data is None or holder_metrics is None or sov_pie is None:
        return

    try:
        return mo.ui.altair_chart(sov_pie)
    except Exception:
        return sov_pie


if __name__ == "__main__":
    app.run()
