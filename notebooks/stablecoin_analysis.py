"""
Stablecoin Analysis Notebook

A marimo notebook for analyzing stablecoin transaction data to determine
whether users primarily use stablecoins (USDC, USDT) for everyday transactions
or as a store of value.

This notebook consumes JSON export files generated by the blockchain explorer
data collection agents and provides interactive visualizations and statistical
analysis.
"""

import marimo

__generated_with = "0.10.9"
app = marimo.App(
    width="medium",
    app_title="Stablecoin Usage Analysis",
)


@app.cell
def imports():
    """Import required libraries and configure the notebook."""
    import marimo as mo
    import pandas as pd
    import altair as alt
    from decimal import Decimal
    from dataclasses import dataclass, field
    from pathlib import Path
    from typing import Optional
    from datetime import datetime
    import json

    return (
        mo,
        pd,
        alt,
        Decimal,
        dataclass,
        field,
        Path,
        Optional,
        datetime,
        json,
    )


@app.cell
def title(mo):
    """Display notebook title and description."""
    mo.md(
        """
        # Stablecoin Usage Analysis

        This notebook analyzes stablecoin transaction data collected by the
        blockchain explorer agents to determine whether users primarily use
        stablecoins (USDC, USDT) for **everyday transactions** or as a
        **store of value**.

        ## Features

        - Load and validate JSON export files from the data collection agents
        - Analyze activity type distribution (transactions vs store of value)
        - Compare usage patterns across different stablecoins (USDC vs USDT)
        - Analyze holder behavior and classification
        - Time series analysis of transaction patterns
        - Cross-chain comparison (Ethereum, BSC, Polygon)
        - Generate summary conclusions with confidence indicators

        ## Getting Started

        1. Select a JSON export file from the output directory below
        2. Or generate sample data to explore the analysis capabilities
        """
    )
    return


@app.cell
def config(Path):
    """Configuration constants."""
    # Default output directory for JSON exports
    OUTPUT_DIR = Path("output")

    # Supported stablecoins
    SUPPORTED_STABLECOINS = ["USDC", "USDT"]

    # Supported chains
    SUPPORTED_CHAINS = ["ethereum", "bsc", "polygon"]
    SUPPORTED_CHAIN_COUNT = 3

    # Activity types
    ACTIVITY_TYPES = ["transaction", "store_of_value", "other"]

    # Required fields for validation
    REQUIRED_TRANSACTION_FIELDS = [
        "transaction_hash", "timestamp", "amount",
        "stablecoin", "chain", "activity_type"
    ]

    return (
        OUTPUT_DIR,
        SUPPORTED_STABLECOINS,
        SUPPORTED_CHAINS,
        SUPPORTED_CHAIN_COUNT,
        ACTIVITY_TYPES,
        REQUIRED_TRANSACTION_FIELDS,
    )


@app.cell
def utility_functions(Decimal):
    """Shared utility functions for the notebook."""

    def format_currency(amount: Decimal) -> str:
        """Format amount with currency notation."""
        if amount >= Decimal("1000000000"):
            return f"${float(amount) / 1e9:.2f}B"
        elif amount >= Decimal("1000000"):
            return f"${float(amount) / 1e6:.2f}M"
        elif amount >= Decimal("1000"):
            return f"${float(amount) / 1e3:.2f}K"
        else:
            return f"${float(amount):.2f}"

    return (format_currency,)


@app.cell
def data_modules():
    """Import data loading and validation modules."""
    import sys
    from pathlib import Path

    # Add notebooks directory to path for imports
    notebooks_dir = Path(__file__).parent if '__file__' in dir() else Path('.')
    if str(notebooks_dir) not in sys.path:
        sys.path.insert(0, str(notebooks_dir))

    from stablecoin_validation import validate_schema
    from stablecoin_loader import LoadedData, load_json_file, load_json_data
    from stablecoin_analysis_functions import (
        ActivityBreakdown,
        analyze_activity_types,
        StablecoinMetrics,
        StablecoinComparison,
        analyze_by_stablecoin,
        calculate_average_transaction_size,
        HolderMetrics,
        TopHolder,
        analyze_holders,
        get_top_holders,
    )

    return (
        validate_schema,
        LoadedData,
        load_json_file,
        load_json_data,
        ActivityBreakdown,
        analyze_activity_types,
        StablecoinMetrics,
        StablecoinComparison,
        analyze_by_stablecoin,
        calculate_average_transaction_size,
        HolderMetrics,
        TopHolder,
        analyze_holders,
        get_top_holders,
    )


@app.cell
def file_selector_ui(mo, OUTPUT_DIR, Path):
    """File selector UI for choosing JSON export files."""
    # Get list of JSON files in output directory
    json_files = []
    if OUTPUT_DIR.exists():
        json_files = sorted([
            f.name for f in OUTPUT_DIR.iterdir()
            if f.suffix == '.json'
        ], reverse=True)

    # Create file selector dropdown
    file_options = {"-- Select a file --": None}
    file_options.update({f: str(OUTPUT_DIR / f) for f in json_files})

    file_selector = mo.ui.dropdown(
        options=file_options,
        label="Select JSON Export File",
        value=None,
    )

    # Sample data toggle
    use_sample_data = mo.ui.checkbox(
        label="Use sample data instead",
        value=False,
    )

    mo.md(f"""
    ## Data Source

    Select a JSON export file from the output directory, or use sample data for testing.

    {file_selector}

    {use_sample_data}

    **Available files:** {len(json_files)} JSON file(s) found in `{OUTPUT_DIR}`
    """)

    return file_selector, use_sample_data, json_files


@app.cell
def load_data_cell(
    mo,
    file_selector,
    use_sample_data,
    load_json_file,
):
    """Load data based on user selection."""
    loaded_data = None
    load_error = None

    if use_sample_data.value:
        # Sample data is handled in generate_sample_cell
        # Just show a message here
        mo.md("""
        âœ… **Using sample data mode.**

        Configure sample data parameters below and the analysis will use generated data.
        """)
    elif file_selector.value:
        try:
            loaded_data = load_json_file(file_selector.value)
        except FileNotFoundError as e:
            load_error = f"âŒ **File not found:** {e}"
        except ValueError as e:
            load_error = f"âŒ **Validation error:**\n\n```\n{e}\n```"
        except Exception as e:
            load_error = f"âŒ **Error loading file:** {type(e).__name__}: {e}"

    return loaded_data, load_error


@app.cell
def display_metadata(mo, loaded_data, load_error):
    """Display metadata after file selection."""
    if load_error:
        mo.md(load_error)
    elif loaded_data:
        meta = loaded_data.metadata
        tx_count = len(loaded_data.transactions_df)
        holder_count = len(loaded_data.holders_df)

        sample_indicator = ""
        if loaded_data.is_sample_data:
            sample_indicator = "\n\nâš ï¸ **Note:** This analysis is based on synthetic sample data, not real blockchain data."

        error_warnings = ""
        if loaded_data.errors:
            error_warnings = f"\n\nâš ï¸ **Data Quality Warnings:** {len(loaded_data.errors)} error(s) during collection"

        mo.md(f"""
        ## Data Loaded Successfully âœ“

        | Field | Value |
        |-------|-------|
        | **Run ID** | `{meta.get('run_id', 'N/A')}` |
        | **Collection Time** | {meta.get('collection_timestamp', 'N/A')} |
        | **Agent Version** | {meta.get('agent_version', 'N/A')} |
        | **Explorers Queried** | {', '.join(meta.get('explorers_queried', []))} |
        | **Total Records** | {meta.get('total_records', 'N/A')} |
        | **Transactions Loaded** | {tx_count} |
        | **Holders Loaded** | {holder_count} |
        {sample_indicator}{error_warnings}
        """)
    else:
        mo.md("""
        ðŸ‘† **Select a JSON file above to begin analysis.**
        """)

    return


@app.cell
def activity_analysis_cell(loaded_data, analyze_activity_types):
    """Analyze activity type distribution."""
    activity_breakdown = None

    if loaded_data is not None:
        activity_breakdown = analyze_activity_types(
            loaded_data.transactions_df
        )

    return (activity_breakdown,)


@app.cell
def activity_breakdown_display(
    mo, loaded_data, activity_breakdown, Decimal, format_currency
):
    """Display activity type breakdown with visualizations."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Build counts table
    counts_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        count = activity_breakdown.counts.get(at, 0)
        pct = activity_breakdown.percentages.get(at, 0.0)
        counts_rows.append(f"| {at} | {count:,} | {pct:.1f}% |")

    total_count = sum(activity_breakdown.counts.values())
    counts_table = "\n".join(counts_rows)

    # Build volumes table
    volumes_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        vol = activity_breakdown.volumes.get(at, Decimal("0"))
        vol_pct = activity_breakdown.volume_percentages.get(at, 0.0)
        volumes_rows.append(
            f"| {at} | {format_currency(vol)} | {vol_pct:.1f}% |"
        )

    total_volume = sum(activity_breakdown.volumes.values())
    volumes_table = "\n".join(volumes_rows)

    mo.md(f"""
    ## Activity Type Analysis

    ### Transaction Counts by Activity Type

    | Activity Type | Count | Percentage |
    |---------------|-------|------------|
    {counts_table}
    | **Total** | **{total_count:,}** | **100.0%** |

    ### Transaction Volume by Activity Type

    | Activity Type | Volume | Percentage |
    |---------------|--------|------------|
    {volumes_table}
    | **Total** | **{format_currency(total_volume)}** | **100.0%** |
    """)

    return


@app.cell
def activity_pie_chart(mo, alt, pd, loaded_data, activity_breakdown):
    """Create pie chart for activity type distribution."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Prepare data for pie chart
    pie_data = pd.DataFrame([
        {
            "activity_type": at,
            "count": activity_breakdown.counts.get(at, 0),
            "percentage": activity_breakdown.percentages.get(at, 0.0),
        }
        for at in ["transaction", "store_of_value", "other"]
        if activity_breakdown.counts.get(at, 0) > 0
    ])

    if pie_data.empty:
        return (None,)

    # Create pie chart using Altair
    pie_chart = alt.Chart(pie_data).mark_arc(innerRadius=50).encode(
        theta=alt.Theta(field="count", type="quantitative"),
        color=alt.Color(
            field="activity_type",
            type="nominal",
            scale=alt.Scale(
                domain=["transaction", "store_of_value", "other"],
                range=["#4C78A8", "#F58518", "#72B7B2"]
            ),
            legend=alt.Legend(title="Activity Type")
        ),
        tooltip=[
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("count:Q", title="Count", format=","),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Transaction Distribution by Activity Type",
        width=300,
        height=300
    )

    mo.md("### Activity Type Distribution (Pie Chart)")
    return (pie_chart,)


@app.cell
def display_pie_chart(mo, loaded_data, activity_breakdown, pie_chart):
    """Display the pie chart."""
    if loaded_data is None or activity_breakdown is None or pie_chart is None:
        return

    try:
        return mo.ui.altair_chart(pie_chart)
    except Exception:
        # Fallback if altair_chart not available
        return pie_chart


@app.cell
def activity_volume_bar_chart(
    mo, alt, pd, loaded_data, activity_breakdown, Decimal
):
    """Create bar chart for volume by activity type."""
    if loaded_data is None or activity_breakdown is None:
        return

    # Prepare data for bar chart
    bar_data = pd.DataFrame([
        {
            "activity_type": at,
            "volume": float(activity_breakdown.volumes.get(at, Decimal("0"))),
            "volume_pct": activity_breakdown.volume_percentages.get(at, 0.0),
        }
        for at in ["transaction", "store_of_value", "other"]
    ])

    if bar_data["volume"].sum() == 0:
        return (None,)
    # Create bar chart using Altair
    bar_chart = alt.Chart(bar_data).mark_bar().encode(
        x=alt.X(
            "activity_type:N",
            title="Activity Type",
            sort=["transaction", "store_of_value", "other"]
        ),
        y=alt.Y("volume:Q", title="Volume (USD)"),
        color=alt.Color(
            "activity_type:N",
            scale=alt.Scale(
                domain=["transaction", "store_of_value", "other"],
                range=["#4C78A8", "#F58518", "#72B7B2"]
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("volume:Q", title="Volume", format=",.2f"),
            alt.Tooltip("volume_pct:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Transaction Volume by Activity Type",
        width=400,
        height=300
    )

    mo.md("### Volume by Activity Type (Bar Chart)")
    return (bar_chart,)


@app.cell
def display_bar_chart(mo, loaded_data, activity_breakdown, bar_chart):
    """Display the bar chart."""
    if loaded_data is None or activity_breakdown is None or bar_chart is None:
        return

    try:
        return mo.ui.altair_chart(bar_chart)
    except Exception:
        # Fallback if altair_chart not available
        return bar_chart


# =============================================================================
# Stablecoin Comparison Analysis (Task 4)
# =============================================================================


@app.cell
def stablecoin_analysis_cell(loaded_data, analyze_by_stablecoin):
    """Analyze transactions grouped by stablecoin type."""
    stablecoin_comparison = None

    if loaded_data is not None:
        stablecoin_comparison = analyze_by_stablecoin(
            loaded_data.transactions_df,
            loaded_data.holders_df,
        )

    return (stablecoin_comparison,)


@app.cell
def stablecoin_comparison_display(
    mo, loaded_data, stablecoin_comparison, format_currency
):
    """Display stablecoin comparison metrics."""
    if loaded_data is None or stablecoin_comparison is None:
        return

    # Build comparison table
    rows = []
    for coin in ["USDC", "USDT"]:
        metrics = stablecoin_comparison.by_stablecoin.get(coin)
        if metrics:
            rows.append(
                f"| {coin} | {metrics.transaction_count:,} | "
                f"{format_currency(metrics.total_volume)} | "
                f"{format_currency(metrics.avg_transaction_size)} | "
                f"{metrics.sov_ratio * 100:.1f}% |"
            )

    table_rows = "\n".join(rows)

    # Build activity distribution comparison
    activity_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        usdc_metrics = stablecoin_comparison.by_stablecoin.get("USDC")
        usdt_metrics = stablecoin_comparison.by_stablecoin.get("USDT")
        usdc_pct = usdc_metrics.activity_distribution.get(at, 0.0) if usdc_metrics else 0.0
        usdt_pct = usdt_metrics.activity_distribution.get(at, 0.0) if usdt_metrics else 0.0
        activity_rows.append(f"| {at} | {usdc_pct:.1f}% | {usdt_pct:.1f}% |")

    activity_table = "\n".join(activity_rows)

    mo.md(f"""
    ## Stablecoin Comparison Analysis

    ### Overview by Stablecoin

    | Stablecoin | Transactions | Total Volume | Avg Tx Size | SoV Ratio |
    |------------|--------------|--------------|-------------|-----------|
    {table_rows}

    ### Activity Type Distribution by Stablecoin

    | Activity Type | USDC | USDT |
    |---------------|------|------|
    {activity_table}

    **Note:** SoV Ratio = percentage of holders classified as store-of-value
    """)

    return


@app.cell
def stablecoin_grouped_bar_chart(
    mo, alt, pd, loaded_data, stablecoin_comparison, Decimal
):
    """Create grouped bar chart comparing USDC vs USDT activity distribution."""
    if loaded_data is None or stablecoin_comparison is None:
        return

    # Prepare data for grouped bar chart
    chart_data = []
    for coin in ["USDC", "USDT"]:
        metrics = stablecoin_comparison.by_stablecoin.get(coin)
        if metrics:
            for at in ["transaction", "store_of_value", "other"]:
                pct = metrics.activity_distribution.get(at, 0.0)
                chart_data.append({
                    "stablecoin": coin,
                    "activity_type": at,
                    "percentage": pct,
                })

    if not chart_data:
        return (None,)

    chart_df = pd.DataFrame(chart_data)

    # Create grouped bar chart
    grouped_chart = alt.Chart(chart_df).mark_bar().encode(
        x=alt.X(
            "activity_type:N",
            title="Activity Type",
            sort=["transaction", "store_of_value", "other"],
            axis=alt.Axis(labelAngle=-45)
        ),
        y=alt.Y("percentage:Q", title="Percentage (%)"),
        color=alt.Color(
            "stablecoin:N",
            scale=alt.Scale(
                domain=["USDC", "USDT"],
                range=["#2775CA", "#26A17B"]  # USDC blue, USDT green
            ),
            legend=alt.Legend(title="Stablecoin")
        ),
        xOffset="stablecoin:N",
        tooltip=[
            alt.Tooltip("stablecoin:N", title="Stablecoin"),
            alt.Tooltip("activity_type:N", title="Activity Type"),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Activity Type Distribution: USDC vs USDT",
        width=400,
        height=300
    )

    mo.md("### Activity Distribution Comparison (Grouped Bar Chart)")
    return (grouped_chart,)


@app.cell
def display_grouped_chart(mo, loaded_data, stablecoin_comparison, grouped_chart):
    """Display the grouped bar chart."""
    if loaded_data is None or stablecoin_comparison is None:
        return
    if grouped_chart is None:
        return

    try:
        return mo.ui.altair_chart(grouped_chart)
    except Exception:
        return grouped_chart


@app.cell
def avg_tx_size_comparison_chart(
    mo, alt, pd, loaded_data, stablecoin_comparison, Decimal
):
    """Create bar chart comparing average transaction size by stablecoin."""
    if loaded_data is None or stablecoin_comparison is None:
        return

    # Prepare data for average transaction size comparison
    avg_data = []
    for coin in ["USDC", "USDT"]:
        metrics = stablecoin_comparison.by_stablecoin.get(coin)
        if metrics and metrics.transaction_count > 0:
            avg_data.append({
                "stablecoin": coin,
                "avg_tx_size": float(metrics.avg_transaction_size),
            })

    if not avg_data:
        return (None,)

    avg_df = pd.DataFrame(avg_data)

    # Create bar chart for average transaction size
    avg_chart = alt.Chart(avg_df).mark_bar().encode(
        x=alt.X("stablecoin:N", title="Stablecoin"),
        y=alt.Y("avg_tx_size:Q", title="Average Transaction Size (USD)"),
        color=alt.Color(
            "stablecoin:N",
            scale=alt.Scale(
                domain=["USDC", "USDT"],
                range=["#2775CA", "#26A17B"]
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip("stablecoin:N", title="Stablecoin"),
            alt.Tooltip("avg_tx_size:Q", title="Avg Tx Size", format=",.2f"),
        ]
    ).properties(
        title="Average Transaction Size: USDC vs USDT",
        width=300,
        height=300
    )

    mo.md("### Average Transaction Size Comparison")
    return (avg_chart,)


@app.cell
def display_avg_chart(mo, loaded_data, stablecoin_comparison, avg_chart):
    """Display the average transaction size chart."""
    if loaded_data is None or stablecoin_comparison is None:
        return
    if avg_chart is None:
        return

    try:
        return mo.ui.altair_chart(avg_chart)
    except Exception:
        return avg_chart


# =============================================================================
# Holder Behavior Analysis (Task 5)
# =============================================================================


@app.cell
def holder_analysis_cell(loaded_data, analyze_holders, get_top_holders):
    """Analyze holder behavior patterns."""
    holder_metrics = None
    top_holders = None

    if loaded_data is not None and not loaded_data.holders_df.empty:
        holder_metrics = analyze_holders(
            loaded_data.holders_df,
            loaded_data.transactions_df,
        )
        top_holders = get_top_holders(loaded_data.holders_df, n=10)

    return holder_metrics, top_holders


@app.cell
def holder_metrics_display(
    mo, loaded_data, holder_metrics, format_currency
):
    """Display holder behavior metrics."""
    if loaded_data is None or holder_metrics is None:
        return

    mo.md(f"""
    ## Holder Behavior Analysis

    ### Holder Classification Summary

    | Metric | Value |
    |--------|-------|
    | **Total Holders** | {holder_metrics.total_holders:,} |
    | **Store of Value Holders** | {holder_metrics.sov_count:,} |
    | **Active Transactors** | {holder_metrics.total_holders - holder_metrics.sov_count:,} |
    | **SoV Percentage** | {holder_metrics.sov_percentage:.1f}% |

    ### Balance Analysis

    | Metric | Store of Value | Active Transactors |
    |--------|----------------|-------------------|
    | **Average Balance** | {format_currency(holder_metrics.avg_balance_sov)} | {format_currency(holder_metrics.avg_balance_active)} |

    ### Holding Period (Store of Value Holders)

    | Metric | Value |
    |--------|-------|
    | **Average Holding Period** | {holder_metrics.avg_holding_period_days:.1f} days |
    | **Median Holding Period** | {holder_metrics.median_holding_period_days:.1f} days |
    """)

    return


@app.cell
def holder_balance_histogram(mo, alt, pd, loaded_data, Decimal):
    """Create histogram of holder balances segmented by SoV status."""
    if loaded_data is None or loaded_data.holders_df.empty:
        return (None,)

    # Prepare data for histogram
    df = loaded_data.holders_df.copy()

    # Convert balance to float for visualization
    df["balance_float"] = df["balance"].apply(
        lambda x: float(x) if isinstance(x, Decimal) else float(str(x)) if x else 0.0
    )

    # Create SoV status label
    df["sov_status"] = df["is_store_of_value"].apply(
        lambda x: "Store of Value" if x else "Active Transactor"
    )

    # Filter out zero balances for better visualization
    df_nonzero = df[df["balance_float"] > 0]

    if df_nonzero.empty:
        return (None,)

    # Create histogram with log scale for better distribution visibility
    histogram = alt.Chart(df_nonzero).mark_bar(opacity=0.7).encode(
        x=alt.X(
            "balance_float:Q",
            bin=alt.Bin(maxbins=30),
            title="Balance (USD)",
            scale=alt.Scale(type="log")
        ),
        y=alt.Y("count():Q", title="Number of Holders"),
        color=alt.Color(
            "sov_status:N",
            scale=alt.Scale(
                domain=["Store of Value", "Active Transactor"],
                range=["#F58518", "#4C78A8"]
            ),
            legend=alt.Legend(title="Holder Type")
        ),
        tooltip=[
            alt.Tooltip("sov_status:N", title="Holder Type"),
            alt.Tooltip("count():Q", title="Count"),
        ]
    ).properties(
        title="Distribution of Holder Balances by Classification",
        width=500,
        height=300
    )

    mo.md("### Holder Balance Distribution (Histogram)")
    return (histogram,)


@app.cell
def display_holder_histogram(mo, loaded_data, histogram):
    """Display the holder balance histogram."""
    if loaded_data is None or histogram is None:
        return

    try:
        return mo.ui.altair_chart(histogram)
    except Exception:
        return histogram


@app.cell
def top_holders_table(mo, loaded_data, top_holders, format_currency):
    """Display top 10 holders table with classifications."""
    if loaded_data is None or not top_holders:
        return

    # Build table rows
    rows = []
    for i, holder in enumerate(top_holders, 1):
        # Mask address for privacy (show first 6 and last 4 chars)
        addr = holder.address
        masked_addr = f"{addr[:6]}...{addr[-4:]}" if len(addr) > 10 else addr

        sov_status = "âœ“ SoV" if holder.is_store_of_value else "Active"

        rows.append(
            f"| {i} | `{masked_addr}` | {format_currency(holder.balance)} | "
            f"{holder.stablecoin} | {holder.chain} | {sov_status} |"
        )

    table_rows = "\n".join(rows)

    mo.md(f"""
    ### Top 10 Holders by Balance

    | Rank | Address | Balance | Stablecoin | Chain | Classification |
    |------|---------|---------|------------|-------|----------------|
    {table_rows}

    **Note:** Addresses are masked for privacy (showing first 6 and last 4 characters).
    """)

    return


@app.cell
def holder_sov_pie_chart(mo, alt, pd, loaded_data, holder_metrics):
    """Create pie chart for holder SoV classification distribution."""
    if loaded_data is None or holder_metrics is None:
        return (None,)

    if holder_metrics.total_holders == 0:
        return (None,)

    # Prepare data for pie chart
    pie_data = pd.DataFrame([
        {
            "classification": "Store of Value",
            "count": holder_metrics.sov_count,
            "percentage": holder_metrics.sov_percentage,
        },
        {
            "classification": "Active Transactor",
            "count": holder_metrics.total_holders - holder_metrics.sov_count,
            "percentage": 100.0 - holder_metrics.sov_percentage,
        }
    ])

    # Filter out zero counts
    pie_data = pie_data[pie_data["count"] > 0]

    if pie_data.empty:
        return (None,)

    # Create pie chart
    sov_pie = alt.Chart(pie_data).mark_arc(innerRadius=50).encode(
        theta=alt.Theta(field="count", type="quantitative"),
        color=alt.Color(
            field="classification",
            type="nominal",
            scale=alt.Scale(
                domain=["Store of Value", "Active Transactor"],
                range=["#F58518", "#4C78A8"]
            ),
            legend=alt.Legend(title="Classification")
        ),
        tooltip=[
            alt.Tooltip("classification:N", title="Classification"),
            alt.Tooltip("count:Q", title="Count", format=","),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Holder Classification Distribution",
        width=300,
        height=300
    )

    mo.md("### Holder Classification (Pie Chart)")
    return (sov_pie,)


@app.cell
def display_sov_pie(mo, loaded_data, holder_metrics, sov_pie):
    """Display the holder SoV pie chart."""
    if loaded_data is None or holder_metrics is None or sov_pie is None:
        return

    try:
        return mo.ui.altair_chart(sov_pie)
    except Exception:
        return sov_pie


# =============================================================================
# Time Series Analysis (Task 6)
# =============================================================================


@app.cell
def time_series_imports():
    """Import time series analysis functions."""
    import sys
    from pathlib import Path

    # Add notebooks directory to path for imports
    notebooks_dir = Path(__file__).parent if '__file__' in dir() else Path('.')
    if str(notebooks_dir) not in sys.path:
        sys.path.insert(0, str(notebooks_dir))

    from stablecoin_analysis_functions import (
        analyze_time_series,
        aggregate_time_series_by_activity,
        aggregate_time_series_by_stablecoin,
        AGGREGATION_PERIODS,
    )

    return (
        analyze_time_series,
        aggregate_time_series_by_activity,
        aggregate_time_series_by_stablecoin,
        AGGREGATION_PERIODS,
    )


@app.cell
def time_series_ui(mo, AGGREGATION_PERIODS):
    """Create UI controls for time series aggregation period."""
    aggregation_selector = mo.ui.dropdown(
        options={
            "Daily": "daily",
            "Weekly": "weekly",
            "Monthly": "monthly",
        },
        label="Aggregation Period",
        value="daily",
    )

    mo.md(f"""
    ## Time Series Analysis

    Analyze transaction patterns over time with different aggregation periods.

    {aggregation_selector}
    """)

    return (aggregation_selector,)


@app.cell
def time_series_analysis_cell(
    loaded_data,
    aggregation_selector,
    aggregate_time_series_by_activity,
    aggregate_time_series_by_stablecoin,
):
    """Perform time series analysis based on selected aggregation."""
    ts_by_activity = None
    ts_by_stablecoin = None

    if loaded_data is not None and not loaded_data.transactions_df.empty:
        aggregation = aggregation_selector.value
        ts_by_activity = aggregate_time_series_by_activity(
            loaded_data.transactions_df, aggregation
        )
        ts_by_stablecoin = aggregate_time_series_by_stablecoin(
            loaded_data.transactions_df, aggregation
        )

    return ts_by_activity, ts_by_stablecoin


@app.cell
def time_series_count_chart(
    mo, alt, pd, loaded_data, ts_by_activity, aggregation_selector
):
    """Create line chart for transaction count over time by activity type."""
    if loaded_data is None or ts_by_activity is None or ts_by_activity.empty:
        return (None,)

    # Prepare data for chart - convert period to string for Altair
    chart_df = ts_by_activity.copy()
    chart_df['period'] = pd.to_datetime(chart_df['period'])

    # Create line chart
    count_chart = alt.Chart(chart_df).mark_line(point=True).encode(
        x=alt.X(
            'period:T',
            title='Date',
            axis=alt.Axis(format='%Y-%m-%d')
        ),
        y=alt.Y('transaction_count:Q', title='Transaction Count'),
        color=alt.Color(
            'activity_type:N',
            scale=alt.Scale(
                domain=['transaction', 'store_of_value', 'other'],
                range=['#4C78A8', '#F58518', '#72B7B2']
            ),
            legend=alt.Legend(title='Activity Type')
        ),
        tooltip=[
            alt.Tooltip('period:T', title='Date', format='%Y-%m-%d'),
            alt.Tooltip('activity_type:N', title='Activity Type'),
            alt.Tooltip('transaction_count:Q', title='Count', format=','),
        ]
    ).properties(
        title=f'Transaction Count Over Time ({aggregation_selector.value.title()})',
        width=600,
        height=300
    )

    mo.md("### Transaction Count Over Time (by Activity Type)")
    return (count_chart,)


@app.cell
def display_count_chart(mo, loaded_data, ts_by_activity, count_chart):
    """Display the transaction count line chart."""
    if loaded_data is None or ts_by_activity is None or count_chart is None:
        return

    try:
        return mo.ui.altair_chart(count_chart)
    except Exception:
        return count_chart


@app.cell
def time_series_volume_chart(
    mo, alt, pd, loaded_data, ts_by_stablecoin, aggregation_selector, Decimal
):
    """Create line chart for transaction volume over time by stablecoin."""
    if (loaded_data is None or ts_by_stablecoin is None or
            ts_by_stablecoin.empty):
        return (None,)

    # Prepare data for chart
    chart_df = ts_by_stablecoin.copy()
    chart_df['period'] = pd.to_datetime(chart_df['period'])
    # Convert Decimal volumes to float for Altair
    chart_df['volume_float'] = chart_df['volume'].apply(
        lambda x: float(x) if isinstance(x, Decimal) else float(str(x))
    )

    # Create line chart
    volume_chart = alt.Chart(chart_df).mark_line(point=True).encode(
        x=alt.X(
            'period:T',
            title='Date',
            axis=alt.Axis(format='%Y-%m-%d')
        ),
        y=alt.Y('volume_float:Q', title='Volume (USD)'),
        color=alt.Color(
            'stablecoin:N',
            scale=alt.Scale(
                domain=['USDC', 'USDT'],
                range=['#2775CA', '#26A17B']
            ),
            legend=alt.Legend(title='Stablecoin')
        ),
        tooltip=[
            alt.Tooltip('period:T', title='Date', format='%Y-%m-%d'),
            alt.Tooltip('stablecoin:N', title='Stablecoin'),
            alt.Tooltip('volume_float:Q', title='Volume', format=',.2f'),
        ]
    ).properties(
        title=f'Transaction Volume Over Time ({aggregation_selector.value})',
        width=600,
        height=300
    )

    mo.md("### Transaction Volume Over Time (by Stablecoin)")
    return (volume_chart,)


@app.cell
def display_volume_chart(mo, loaded_data, ts_by_stablecoin, volume_chart):
    """Display the transaction volume line chart."""
    if loaded_data is None or ts_by_stablecoin is None or volume_chart is None:
        return

    try:
        return mo.ui.altair_chart(volume_chart)
    except Exception:
        return volume_chart


@app.cell
def time_series_summary(
    mo, loaded_data, ts_by_activity, ts_by_stablecoin, format_currency, Decimal
):
    """Display time series summary statistics."""
    if loaded_data is None or ts_by_activity is None:
        return

    if ts_by_activity.empty:
        mo.md("No time series data available.")
        return

    # Calculate summary statistics
    total_periods = ts_by_activity['period'].nunique()
    total_transactions = ts_by_activity['transaction_count'].sum()

    # Calculate total volume
    total_volume = Decimal("0")
    for vol in ts_by_activity['volume']:
        if isinstance(vol, Decimal):
            total_volume += vol
        else:
            total_volume += Decimal(str(vol))

    # Find peak period by transaction count
    period_totals = ts_by_activity.groupby('period')['transaction_count'].sum()
    if not period_totals.empty:
        peak_period = period_totals.idxmax()
        peak_count = period_totals.max()
    else:
        peak_period = "N/A"
        peak_count = 0

    mo.md(f"""
    ### Time Series Summary

    | Metric | Value |
    |--------|-------|
    | **Time Periods** | {total_periods} |
    | **Total Transactions** | {total_transactions:,} |
    | **Total Volume** | {format_currency(total_volume)} |
    | **Peak Period** | {peak_period} ({peak_count:,} transactions) |
    """)

    return


# =============================================================================
# Chain Comparison Analysis (Task 7)
# =============================================================================


@app.cell
def chain_analysis_imports():
    """Import chain analysis functions."""
    import sys
    from pathlib import Path

    # Add notebooks directory to path for imports
    notebooks_dir = Path(__file__).parent if '__file__' in dir() else Path('.')
    if str(notebooks_dir) not in sys.path:
        sys.path.insert(0, str(notebooks_dir))

    from stablecoin_analysis_functions import (
        ChainMetrics,
        analyze_by_chain,
        get_chain_activity_distribution,
        SUPPORTED_CHAINS,
    )

    return (
        ChainMetrics,
        analyze_by_chain,
        get_chain_activity_distribution,
        SUPPORTED_CHAINS,
    )


@app.cell
def chain_analysis_cell(loaded_data, analyze_by_chain):
    """Analyze transactions grouped by blockchain chain."""
    chain_metrics = None

    if loaded_data is not None and not loaded_data.transactions_df.empty:
        chain_metrics = analyze_by_chain(
            loaded_data.transactions_df,
            loaded_data.holders_df,
        )

    return (chain_metrics,)


@app.cell
def chain_metrics_display(mo, loaded_data, chain_metrics, format_currency):
    """Display chain comparison metrics table."""
    if loaded_data is None or chain_metrics is None:
        return

    # Build comparison table
    rows = []
    for metrics in chain_metrics:
        # Format gas cost
        if metrics.avg_gas_cost is not None:
            gas_display = f"{float(metrics.avg_gas_cost):.6f}"
        else:
            gas_display = "N/A"

        # Gas exclusion note
        gas_note = ""
        if metrics.excluded_gas_count > 0:
            gas_note = f" ({metrics.excluded_gas_count} excluded)"

        rows.append(
            f"| {metrics.chain.title()} | {metrics.transaction_count:,} | "
            f"{format_currency(metrics.total_volume)} | "
            f"{format_currency(metrics.avg_transaction_size)} | "
            f"{gas_display}{gas_note} | "
            f"{metrics.sov_ratio * 100:.1f}% |"
        )

    table_rows = "\n".join(rows)

    # Build activity distribution table
    activity_rows = []
    for at in ["transaction", "store_of_value", "other"]:
        row_values = [at]
        for metrics in chain_metrics:
            pct = metrics.activity_distribution.get(at, 0.0)
            row_values.append(f"{pct:.1f}%")
        activity_rows.append("| " + " | ".join(row_values) + " |")

    activity_table = "\n".join(activity_rows)

    mo.md(f"""
    ## Chain Comparison Analysis

    Compare stablecoin usage patterns across different blockchain networks.

    ### Overview by Chain

    | Chain | Transactions | Total Volume | Avg Tx Size | Avg Gas Cost | SoV Ratio |
    |-------|--------------|--------------|-------------|--------------|-----------|
    {table_rows}

    **Note:** Gas cost is in native token units (ETH/BNB/MATIC). Transactions with
    missing gas data are excluded from gas cost calculations.

    ### Activity Type Distribution by Chain

    | Activity Type | Ethereum | BSC | Polygon |
    |---------------|----------|-----|---------|
    {activity_table}

    **Note:** SoV Ratio = percentage of holders classified as store-of-value on each chain
    """)

    return


@app.cell
def chain_stacked_bar_chart(
    mo, alt, pd, loaded_data, get_chain_activity_distribution
):
    """Create stacked bar chart for activity distribution per chain."""
    if loaded_data is None or loaded_data.transactions_df.empty:
        return (None,)

    # Get activity distribution data
    chart_df = get_chain_activity_distribution(loaded_data.transactions_df)

    if chart_df.empty or chart_df['count'].sum() == 0:
        return (None,)

    # Create stacked bar chart
    stacked_chart = alt.Chart(chart_df).mark_bar().encode(
        x=alt.X(
            'chain:N',
            title='Blockchain',
            sort=['ethereum', 'bsc', 'polygon'],
            axis=alt.Axis(labelAngle=0)
        ),
        y=alt.Y(
            'percentage:Q',
            title='Percentage (%)',
            stack='normalize',
            scale=alt.Scale(domain=[0, 100])
        ),
        color=alt.Color(
            'activity_type:N',
            scale=alt.Scale(
                domain=['transaction', 'store_of_value', 'other'],
                range=['#4C78A8', '#F58518', '#72B7B2']
            ),
            legend=alt.Legend(title='Activity Type')
        ),
        order=alt.Order(
            'activity_type:N',
            sort='ascending'
        ),
        tooltip=[
            alt.Tooltip('chain:N', title='Chain'),
            alt.Tooltip('activity_type:N', title='Activity Type'),
            alt.Tooltip('count:Q', title='Count', format=','),
            alt.Tooltip('percentage:Q', title='Percentage', format='.1f'),
        ]
    ).properties(
        title='Activity Type Distribution by Chain',
        width=400,
        height=300
    )

    mo.md("### Activity Distribution by Chain (Stacked Bar Chart)")
    return (stacked_chart,)


@app.cell
def display_stacked_chart(
    mo, loaded_data, get_chain_activity_distribution, stacked_chart
):
    """Display the stacked bar chart."""
    if loaded_data is None or stacked_chart is None:
        return

    try:
        return mo.ui.altair_chart(stacked_chart)
    except Exception:
        return stacked_chart


@app.cell
def chain_volume_bar_chart(mo, alt, pd, loaded_data, chain_metrics, Decimal):
    """Create bar chart comparing transaction volume by chain."""
    if loaded_data is None or chain_metrics is None:
        return (None,)

    # Prepare data for bar chart
    chart_data = []
    for metrics in chain_metrics:
        if metrics.transaction_count > 0:
            chart_data.append({
                'chain': metrics.chain.title(),
                'volume': float(metrics.total_volume),
                'transaction_count': metrics.transaction_count,
            })

    if not chart_data:
        return (None,)

    chart_df = pd.DataFrame(chart_data)

    # Create bar chart for volume
    volume_bar = alt.Chart(chart_df).mark_bar().encode(
        x=alt.X(
            'chain:N',
            title='Blockchain',
            sort=['Ethereum', 'Bsc', 'Polygon']
        ),
        y=alt.Y('volume:Q', title='Total Volume (USD)'),
        color=alt.Color(
            'chain:N',
            scale=alt.Scale(
                domain=['Ethereum', 'Bsc', 'Polygon'],
                range=['#627EEA', '#F3BA2F', '#8247E5']
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip('chain:N', title='Chain'),
            alt.Tooltip('volume:Q', title='Volume', format=',.2f'),
            alt.Tooltip('transaction_count:Q', title='Transactions', format=','),
        ]
    ).properties(
        title='Transaction Volume by Chain',
        width=350,
        height=300
    )

    mo.md("### Transaction Volume by Chain")
    return (volume_bar,)


@app.cell
def display_volume_bar(mo, loaded_data, chain_metrics, volume_bar):
    """Display the volume bar chart."""
    if loaded_data is None or chain_metrics is None or volume_bar is None:
        return

    try:
        return mo.ui.altair_chart(volume_bar)
    except Exception:
        return volume_bar


@app.cell
def chain_avg_tx_size_chart(mo, alt, pd, loaded_data, chain_metrics, Decimal):
    """Create bar chart comparing average transaction size by chain."""
    if loaded_data is None or chain_metrics is None:
        return (None,)

    # Prepare data for bar chart
    chart_data = []
    for metrics in chain_metrics:
        if metrics.transaction_count > 0:
            chart_data.append({
                'chain': metrics.chain.title(),
                'avg_tx_size': float(metrics.avg_transaction_size),
            })

    if not chart_data:
        return (None,)

    chart_df = pd.DataFrame(chart_data)

    # Create bar chart for average transaction size
    avg_tx_chart = alt.Chart(chart_df).mark_bar().encode(
        x=alt.X(
            'chain:N',
            title='Blockchain',
            sort=['Ethereum', 'Bsc', 'Polygon']
        ),
        y=alt.Y('avg_tx_size:Q', title='Average Transaction Size (USD)'),
        color=alt.Color(
            'chain:N',
            scale=alt.Scale(
                domain=['Ethereum', 'Bsc', 'Polygon'],
                range=['#627EEA', '#F3BA2F', '#8247E5']
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip('chain:N', title='Chain'),
            alt.Tooltip('avg_tx_size:Q', title='Avg Tx Size', format=',.2f'),
        ]
    ).properties(
        title='Average Transaction Size by Chain',
        width=350,
        height=300
    )

    mo.md("### Average Transaction Size by Chain")
    return (avg_tx_chart,)


@app.cell
def display_avg_tx_chart(mo, loaded_data, chain_metrics, avg_tx_chart):
    """Display the average transaction size chart."""
    if loaded_data is None or chain_metrics is None or avg_tx_chart is None:
        return

    try:
        return mo.ui.altair_chart(avg_tx_chart)
    except Exception:
        return avg_tx_chart


@app.cell
def chain_gas_cost_chart(mo, alt, pd, loaded_data, chain_metrics):
    """Create bar chart comparing average gas cost by chain."""
    if loaded_data is None or chain_metrics is None:
        return (None,)

    # Prepare data for bar chart - only include chains with gas data
    chart_data = []
    for metrics in chain_metrics:
        if metrics.avg_gas_cost is not None:
            chart_data.append({
                'chain': metrics.chain.title(),
                'avg_gas_cost': float(metrics.avg_gas_cost),
                'excluded_count': metrics.excluded_gas_count,
            })

    if not chart_data:
        mo.md("""
        ### Average Gas Cost by Chain

        *No gas cost data available. Transactions may be missing gas_used or
        gas_price fields.*
        """)
        return (None,)

    chart_df = pd.DataFrame(chart_data)

    # Create bar chart for gas cost
    gas_chart = alt.Chart(chart_df).mark_bar().encode(
        x=alt.X(
            'chain:N',
            title='Blockchain',
            sort=['Ethereum', 'Bsc', 'Polygon']
        ),
        y=alt.Y(
            'avg_gas_cost:Q',
            title='Average Gas Cost (Native Token)'
        ),
        color=alt.Color(
            'chain:N',
            scale=alt.Scale(
                domain=['Ethereum', 'Bsc', 'Polygon'],
                range=['#627EEA', '#F3BA2F', '#8247E5']
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip('chain:N', title='Chain'),
            alt.Tooltip('avg_gas_cost:Q', title='Avg Gas Cost', format='.6f'),
            alt.Tooltip('excluded_count:Q', title='Excluded Txs', format=','),
        ]
    ).properties(
        title='Average Gas Cost by Chain (in Native Token)',
        width=350,
        height=300
    )

    mo.md("### Average Gas Cost by Chain")
    return (gas_chart,)


@app.cell
def display_gas_chart(mo, loaded_data, chain_metrics, gas_chart):
    """Display the gas cost chart."""
    if loaded_data is None or chain_metrics is None or gas_chart is None:
        return

    try:
        return mo.ui.altair_chart(gas_chart)
    except Exception:
        return gas_chart


@app.cell
def chain_sov_ratio_chart(mo, alt, pd, loaded_data, chain_metrics):
    """Create bar chart comparing SoV ratio by chain."""
    if loaded_data is None or chain_metrics is None:
        return (None,)

    # Prepare data for bar chart
    chart_data = []
    for metrics in chain_metrics:
        chart_data.append({
            'chain': metrics.chain.title(),
            'sov_ratio': metrics.sov_ratio * 100,  # Convert to percentage
        })

    if not chart_data:
        return (None,)

    chart_df = pd.DataFrame(chart_data)

    # Create bar chart for SoV ratio
    sov_chart = alt.Chart(chart_df).mark_bar().encode(
        x=alt.X(
            'chain:N',
            title='Blockchain',
            sort=['Ethereum', 'Bsc', 'Polygon']
        ),
        y=alt.Y(
            'sov_ratio:Q',
            title='Store of Value Ratio (%)',
            scale=alt.Scale(domain=[0, 100])
        ),
        color=alt.Color(
            'chain:N',
            scale=alt.Scale(
                domain=['Ethereum', 'Bsc', 'Polygon'],
                range=['#627EEA', '#F3BA2F', '#8247E5']
            ),
            legend=None
        ),
        tooltip=[
            alt.Tooltip('chain:N', title='Chain'),
            alt.Tooltip('sov_ratio:Q', title='SoV Ratio', format='.1f'),
        ]
    ).properties(
        title='Store of Value Ratio by Chain',
        width=350,
        height=300
    )

    mo.md("### Store of Value Ratio by Chain")
    return (sov_chart,)


@app.cell
def display_sov_chart(mo, loaded_data, chain_metrics, sov_chart):
    """Display the SoV ratio chart."""
    if loaded_data is None or chain_metrics is None or sov_chart is None:
        return

    try:
        return mo.ui.altair_chart(sov_chart)
    except Exception:
        return sov_chart


# =============================================================================
# Sample Data Generator and Conclusions (Task 8)
# =============================================================================


@app.cell
def sample_data_imports():
    """Import sample data generation and conclusion functions."""
    import sys
    from pathlib import Path

    # Add notebooks directory to path for imports
    notebooks_dir = Path(__file__).parent if '__file__' in dir() else Path('.')
    if str(notebooks_dir) not in sys.path:
        sys.path.insert(0, str(notebooks_dir))

    from sample_data_generator import SampleDataConfig, generate_sample_data
    from stablecoin_analysis_functions import (
        ConfidenceLevel,
        ConfidenceMetrics,
        Conclusion,
        calculate_confidence,
        generate_conclusions,
        get_data_quality_warnings,
    )

    return (
        SampleDataConfig,
        generate_sample_data,
        ConfidenceLevel,
        ConfidenceMetrics,
        Conclusion,
        calculate_confidence,
        generate_conclusions,
        get_data_quality_warnings,
    )


@app.cell
def sample_data_ui(mo):
    """Create UI controls for sample data generation."""
    # Sample size slider
    sample_size_slider = mo.ui.slider(
        start=100,
        stop=2000,
        step=100,
        value=500,
        label="Number of Transactions",
    )

    # Number of holders slider
    holders_slider = mo.ui.slider(
        start=10,
        stop=200,
        step=10,
        value=50,
        label="Number of Holders",
    )

    # SoV ratio slider
    sov_ratio_slider = mo.ui.slider(
        start=0.0,
        stop=1.0,
        step=0.05,
        value=0.3,
        label="Store of Value Ratio",
    )

    # Generate button
    generate_button = mo.ui.button(
        label="Generate Sample Data",
        kind="success",
    )

    mo.md(f"""
    ## Sample Data Configuration

    Configure and generate synthetic sample data for testing the analysis.

    {sample_size_slider}

    {holders_slider}

    {sov_ratio_slider}

    {generate_button}
    """)

    return (
        sample_size_slider,
        holders_slider,
        sov_ratio_slider,
        generate_button,
    )


@app.cell
def generate_sample_cell(
    mo,
    use_sample_data,
    sample_size_slider,
    holders_slider,
    sov_ratio_slider,
    generate_button,
    SampleDataConfig,
    generate_sample_data,
):
    """Generate sample data when button is clicked or checkbox is checked."""
    sample_data = None

    if use_sample_data.value:
        # Generate sample data with current slider values
        config = SampleDataConfig(
            num_transactions=sample_size_slider.value,
            num_holders=holders_slider.value,
            sov_ratio=sov_ratio_slider.value,
        )
        sample_data = generate_sample_data(config)

        mo.md(f"""
        âœ… **Sample data generated successfully!**

        - Transactions: {len(sample_data.transactions_df):,}
        - Holders: {len(sample_data.holders_df):,}
        - SoV Ratio: {sov_ratio_slider.value:.0%}

        âš ï¸ **Note:** This analysis is based on synthetic sample data, not real blockchain data.
        """)

    return (sample_data,)


@app.cell
def merge_data_sources(loaded_data, sample_data):
    """Merge loaded data and sample data into a single source.
    
    Returns the merged data as 'loaded_data' so downstream analysis cells
    continue to work without modification.
    """
    # Use sample data if available, otherwise use loaded data
    # Return as loaded_data to maintain compatibility with downstream cells
    if sample_data is not None:
        loaded_data = sample_data
    return (loaded_data,)


# =============================================================================
# ZenML Pipeline Control UI
# =============================================================================


@app.cell
def zenml_bridge_import():
    """Import ZenML bridge for pipeline control."""
    try:
        from .zenml_bridge import (
            ZenMLNotebookBridge,
            PipelineInfo,
            PipelineRunStatus,
            LoadedArtifacts,
        )
        zenml_available = True
    except ImportError:
        ZenMLNotebookBridge = None
        PipelineInfo = None
        PipelineRunStatus = None
        LoadedArtifacts = None
        zenml_available = False
    
    return (
        ZenMLNotebookBridge,
        PipelineInfo,
        PipelineRunStatus,
        LoadedArtifacts,
        zenml_available,
    )


@app.cell
def zenml_bridge_init(ZenMLNotebookBridge, zenml_available):
    """Initialize ZenML bridge for pipeline control."""
    zenml_bridge = None
    if zenml_available and ZenMLNotebookBridge is not None:
        zenml_bridge = ZenMLNotebookBridge()
    return (zenml_bridge,)


@app.cell
def pipeline_list_cell(mo, zenml_bridge, zenml_available):
    """Display available ZenML pipelines and their status.
    
    Requirements: 13.1
    """
    if not zenml_available or zenml_bridge is None:
        mo.md("""
        ## ðŸ”§ ZenML Pipeline Control
        
        > âš ï¸ ZenML is not available. Pipeline control features are disabled.
        > Install ZenML and configure it to enable pipeline orchestration.
        """)
        return (None,)
    
    # Get list of pipelines
    pipelines = zenml_bridge.list_pipelines()
    
    if not pipelines:
        mo.md("""
        ## ðŸ”§ ZenML Pipeline Control
        
        No pipelines found. Run a pipeline first to see it listed here.
        """)
        return (pipelines,)
    
    # Build pipeline status table
    rows = []
    for p in pipelines:
        status_icon = {
            "completed": "âœ…",
            "running": "ðŸ”„",
            "failed": "âŒ",
            "never_run": "âšª",
        }.get(p.last_run_status, "âšª")
        
        last_run = p.last_run_time.strftime("%Y-%m-%d %H:%M") if p.last_run_time else "Never"
        
        rows.append(
            f"| {p.name} | {status_icon} {p.last_run_status or 'Never run'} | "
            f"{last_run} | {p.total_runs} |"
        )
    
    table_rows = "\n".join(rows)
    
    mo.md(f"""
    ## ðŸ”§ ZenML Pipeline Control
    
    ### Available Pipelines
    
    | Pipeline | Status | Last Run | Total Runs |
    |----------|--------|----------|------------|
    {table_rows}
    """)
    
    return (pipelines,)


@app.cell
def pipeline_parameters_ui(mo, zenml_available):
    """Create UI controls for pipeline parameters.
    
    Requirements: 13.2
    """
    if not zenml_available:
        return (None, None, None, None)
    
    # Pipeline selector
    pipeline_selector = mo.ui.dropdown(
        options=[
            "stablecoin_master_pipeline",
            "stablecoin_collection_pipeline",
            "stablecoin_analysis_pipeline",
        ],
        value="stablecoin_master_pipeline",
        label="Select Pipeline",
    )
    
    # Stablecoins selector
    stablecoins_selector = mo.ui.multiselect(
        options=["USDC", "USDT"],
        value=["USDC", "USDT"],
        label="Stablecoins",
    )
    
    # Date range slider
    date_range_slider = mo.ui.slider(
        start=1,
        stop=30,
        value=7,
        label="Date Range (days)",
    )
    
    # Max records slider
    max_records_slider = mo.ui.slider(
        start=100,
        stop=5000,
        value=1000,
        step=100,
        label="Max Records per Stablecoin",
    )
    
    mo.md("""
    ### Pipeline Parameters
    
    Configure the parameters for the pipeline run:
    """)
    
    mo.hstack([
        pipeline_selector,
        stablecoins_selector,
    ])
    
    mo.hstack([
        date_range_slider,
        max_records_slider,
    ])
    
    return (
        pipeline_selector,
        stablecoins_selector,
        date_range_slider,
        max_records_slider,
    )


@app.cell
def pipeline_trigger_button(mo, zenml_available):
    """Create Run Pipeline button.
    
    Requirements: 13.2
    """
    if not zenml_available:
        return (None,)
    
    run_button = mo.ui.button(
        label="ðŸš€ Run Pipeline",
        kind="success",
    )
    
    return (run_button,)


@app.cell
def pipeline_trigger_cell(
    mo,
    zenml_bridge,
    zenml_available,
    run_button,
    pipeline_selector,
    stablecoins_selector,
    date_range_slider,
    max_records_slider,
):
    """Handle pipeline trigger and display progress.
    
    Requirements: 13.2, 13.3
    """
    if not zenml_available or zenml_bridge is None:
        return (None, None)
    
    if run_button is None or not run_button.value:
        return (None, None)
    
    # Get selected parameters
    pipeline_name = pipeline_selector.value if pipeline_selector else "stablecoin_master_pipeline"
    stablecoins = list(stablecoins_selector.value) if stablecoins_selector else ["USDC", "USDT"]
    date_range_days = date_range_slider.value if date_range_slider else 7
    max_records = max_records_slider.value if max_records_slider else 1000
    
    # Build parameters
    parameters = {
        "stablecoins": stablecoins,
        "date_range_days": date_range_days,
        "max_records": max_records,
    }
    
    # Trigger pipeline
    try:
        run_id = zenml_bridge.trigger_pipeline(pipeline_name, parameters)
        
        mo.md(f"""
        ### Pipeline Triggered âœ…
        
        | Field | Value |
        |-------|-------|
        | **Pipeline** | {pipeline_name} |
        | **Run ID** | `{run_id}` |
        | **Stablecoins** | {', '.join(stablecoins)} |
        | **Date Range** | {date_range_days} days |
        | **Max Records** | {max_records:,} |
        
        The pipeline is now running. Check the status below.
        """)
        
        return (run_id, None)
        
    except Exception as e:
        error_msg = str(e)
        mo.md(f"""
        ### Pipeline Trigger Failed âŒ
        
        Error: {error_msg}
        """)
        return (None, error_msg)


@app.cell
def pipeline_status_cell(mo, zenml_bridge, zenml_available, run_id):
    """Display pipeline run status with progress indicators.
    
    Requirements: 13.3
    """
    if not zenml_available or zenml_bridge is None or run_id is None:
        return
    
    # Get run status
    status = zenml_bridge.get_run_status(run_id)
    
    if status is None:
        mo.md(f"""
        ### Run Status
        
        Unable to get status for run `{run_id}`
        """)
        return
    
    # Status icon
    status_icons = {
        "completed": "âœ…",
        "running": "ðŸ”„",
        "failed": "âŒ",
        "initializing": "â³",
        "pending": "â³",
    }
    status_icon = status_icons.get(status.status, "âšª")
    
    # Build step status table
    step_rows = []
    for step_name, step_status in status.steps.items():
        step_icon = status_icons.get(step_status, "âšª")
        step_rows.append(f"| {step_name} | {step_icon} {step_status} |")
    
    step_table = "\n".join(step_rows) if step_rows else "| No steps yet | â³ |"
    
    # Error message if failed
    error_section = ""
    if status.is_failed and status.error_message:
        error_section = f"""
        ### Error Details
        
        ```
        {status.error_message}
        ```
        """
    
    mo.md(f"""
    ### Run Status: {status_icon} {status.status.upper()}
    
    | Field | Value |
    |-------|-------|
    | **Run ID** | `{status.run_id}` |
    | **Pipeline** | {status.pipeline_name} |
    | **Started** | {status.start_time.strftime('%Y-%m-%d %H:%M:%S') if status.start_time else 'N/A'} |
    | **Ended** | {status.end_time.strftime('%Y-%m-%d %H:%M:%S') if status.end_time else 'In progress'} |
    
    ### Step Progress
    
    | Step | Status |
    |------|--------|
    {step_table}
    
    {error_section}
    """)
    
    return


# =============================================================================
# Pipeline Artifact Visualization Layer (Task 15)
# =============================================================================


@app.cell
def artifact_loading_state():
    """State for artifact loading and refresh.
    
    Requirements: 14.1, 14.4
    """
    # Track loaded artifacts state
    pipeline_artifacts = None
    artifacts_loaded = False
    artifacts_error = None
    
    return pipeline_artifacts, artifacts_loaded, artifacts_error


@app.cell
def artifact_refresh_ui(mo, zenml_available):
    """Create refresh button for loading latest pipeline artifacts.
    
    Requirements: 14.1, 14.4
    """
    if not zenml_available:
        return (None,)
    
    refresh_button = mo.ui.button(
        label="ðŸ”„ Load Latest Pipeline Results",
        kind="primary",
    )
    
    # Pipeline selector for artifact loading
    artifact_pipeline_selector = mo.ui.dropdown(
        options=[
            "stablecoin_master_pipeline",
            "stablecoin_analysis_pipeline",
        ],
        value="stablecoin_master_pipeline",
        label="Load artifacts from pipeline",
    )
    
    return refresh_button, artifact_pipeline_selector


@app.cell
def load_pipeline_artifacts_cell(
    mo,
    zenml_bridge,
    zenml_available,
    refresh_button,
    artifact_pipeline_selector,
):
    """Load latest pipeline artifacts via ZenML bridge.
    
    Requirements: 14.1, 14.4
    Task: 15.1 Create artifact loading cells
    """
    pipeline_artifacts = None
    artifacts_error = None
    
    if not zenml_available or zenml_bridge is None:
        mo.md("""
        ## ðŸ“Š Pipeline Results Visualization
        
        > âš ï¸ ZenML is not available. Cannot load pipeline artifacts.
        > Use the file selector above to load data from JSON exports instead.
        """)
        return pipeline_artifacts, artifacts_error
    
    if refresh_button is None:
        return pipeline_artifacts, artifacts_error
    
    # Only load when button is clicked
    if not refresh_button.value:
        mo.md("""
        ## ðŸ“Š Pipeline Results Visualization
        
        Click the button below to load the latest results from ZenML pipelines.
        
        This will load:
        - Activity analysis results
        - Holder metrics
        - Time series data
        - Chain metrics
        - ML predictions (SoV and wallet classification)
        """)
        return pipeline_artifacts, artifacts_error
    
    # Get selected pipeline
    pipeline_name = (
        artifact_pipeline_selector.value 
        if artifact_pipeline_selector 
        else "stablecoin_master_pipeline"
    )
    
    try:
        pipeline_artifacts = zenml_bridge.load_latest_artifacts(pipeline_name)
        
        if pipeline_artifacts is None:
            artifacts_error = f"No completed runs found for pipeline '{pipeline_name}'"
            mo.md(f"""
            ## ðŸ“Š Pipeline Results Visualization
            
            âš ï¸ {artifacts_error}
            
            Run the pipeline first to generate results.
            """)
        else:
            # Display run metadata
            run_time = (
                pipeline_artifacts.run_timestamp.strftime("%Y-%m-%d %H:%M:%S")
                if pipeline_artifacts.run_timestamp
                else "Unknown"
            )
            artifact_count = len(pipeline_artifacts.artifacts)
            is_mock = pipeline_artifacts.metadata.get("is_mock", False)
            
            mock_indicator = ""
            if is_mock:
                mock_indicator = "\n\n> âš ï¸ **Note:** Displaying mock data. Connect to ZenML for real pipeline results."
            
            mo.md(f"""
            ## ðŸ“Š Pipeline Results Visualization
            
            âœ… **Artifacts loaded successfully!**
            
            | Field | Value |
            |-------|-------|
            | **Run ID** | `{pipeline_artifacts.run_id}` |
            | **Pipeline** | {pipeline_name} |
            | **Run Time** | {run_time} |
            | **Artifacts Loaded** | {artifact_count} |
            {mock_indicator}
            """)
            
    except Exception as e:
        artifacts_error = str(e)
        mo.md(f"""
        ## ðŸ“Š Pipeline Results Visualization
        
        âŒ **Failed to load artifacts:** {artifacts_error}
        """)
    
    return pipeline_artifacts, artifacts_error


@app.cell
def display_artifact_refresh_controls(
    mo,
    zenml_available,
    refresh_button,
    artifact_pipeline_selector,
):
    """Display the artifact loading controls.
    
    Requirements: 14.1, 14.4
    """
    if not zenml_available or refresh_button is None:
        return
    
    mo.hstack([
        artifact_pipeline_selector,
        refresh_button,
    ])
    
    return


# =============================================================================
# ML Prediction Visualization (Task 15.2)
# =============================================================================


@app.cell
def ml_predictions_header(mo, pipeline_artifacts):
    """Display ML predictions section header.
    
    Requirements: 12.5, 14.3
    Task: 15.2 Create ML prediction visualization cells
    """
    if pipeline_artifacts is None:
        return
    
    # Check if ML predictions are available
    has_sov = "sov_predictions" in pipeline_artifacts.artifacts
    has_wallet = "wallet_classifications" in pipeline_artifacts.artifacts
    
    if not has_sov and not has_wallet:
        mo.md("""
        ### ML Predictions
        
        > No ML prediction data available in the loaded artifacts.
        > Run the master pipeline with ML inference to generate predictions.
        """)
        return
    
    mo.md("""
    ### ðŸ¤– ML Predictions
    
    Machine learning model predictions from the pipeline run.
    """)
    
    return


@app.cell
def sov_prediction_data(pipeline_artifacts, pd):
    """Extract SoV prediction data from artifacts.
    
    Requirements: 12.5, 14.3
    """
    sov_predictions_df = None
    
    if pipeline_artifacts is None:
        return (sov_predictions_df,)
    
    sov_data = pipeline_artifacts.artifacts.get("sov_predictions")
    
    if sov_data is None:
        return (sov_predictions_df,)
    
    # Handle different data formats
    if isinstance(sov_data, pd.DataFrame):
        sov_predictions_df = sov_data
    elif isinstance(sov_data, dict):
        # Convert dict to DataFrame
        if "address" in sov_data and "sov_probability" in sov_data:
            sov_predictions_df = pd.DataFrame(sov_data)
        elif "predictions" in sov_data:
            sov_predictions_df = pd.DataFrame(sov_data["predictions"])
    
    return (sov_predictions_df,)


@app.cell
def sov_prediction_distribution_chart(mo, alt, pd, sov_predictions_df):
    """Create SoV prediction distribution chart.
    
    Requirements: 12.5, 14.3
    Task: 15.2 Create ML prediction visualization cells
    """
    if sov_predictions_df is None or sov_predictions_df.empty:
        return (None,)
    
    # Check for probability column
    prob_col = None
    for col in ["sov_probability", "probability", "score"]:
        if col in sov_predictions_df.columns:
            prob_col = col
            break
    
    if prob_col is None:
        return (None,)
    
    # Create histogram of SoV probabilities
    sov_hist = alt.Chart(sov_predictions_df).mark_bar().encode(
        x=alt.X(
            f"{prob_col}:Q",
            bin=alt.Bin(maxbins=20),
            title="SoV Probability",
        ),
        y=alt.Y("count():Q", title="Number of Holders"),
        color=alt.condition(
            alt.datum[prob_col] >= 0.5,
            alt.value("#F58518"),  # Orange for likely SoV
            alt.value("#4C78A8"),  # Blue for likely active
        ),
        tooltip=[
            alt.Tooltip(f"{prob_col}:Q", title="Probability", format=".2f"),
            alt.Tooltip("count():Q", title="Count"),
        ]
    ).properties(
        title="Store of Value Prediction Distribution",
        width=500,
        height=300,
    )
    
    mo.md("#### SoV Prediction Distribution")
    return (sov_hist,)


@app.cell
def display_sov_prediction_chart(mo, sov_predictions_df, sov_hist):
    """Display the SoV prediction histogram."""
    if sov_predictions_df is None or sov_hist is None:
        return
    
    try:
        return mo.ui.altair_chart(sov_hist)
    except Exception:
        return sov_hist


@app.cell
def sov_prediction_summary(mo, sov_predictions_df):
    """Display SoV prediction summary statistics.
    
    Requirements: 12.5, 14.3
    """
    if sov_predictions_df is None or sov_predictions_df.empty:
        return
    
    # Find probability column
    prob_col = None
    for col in ["sov_probability", "probability", "score"]:
        if col in sov_predictions_df.columns:
            prob_col = col
            break
    
    if prob_col is None:
        return
    
    total_holders = len(sov_predictions_df)
    predicted_sov = (sov_predictions_df[prob_col] >= 0.5).sum()
    predicted_active = total_holders - predicted_sov
    avg_probability = sov_predictions_df[prob_col].mean()
    
    mo.md(f"""
    #### SoV Prediction Summary
    
    | Metric | Value |
    |--------|-------|
    | **Total Holders Analyzed** | {total_holders:,} |
    | **Predicted SoV (â‰¥50%)** | {predicted_sov:,} ({predicted_sov/total_holders*100:.1f}%) |
    | **Predicted Active (<50%)** | {predicted_active:,} ({predicted_active/total_holders*100:.1f}%) |
    | **Average SoV Probability** | {avg_probability:.3f} |
    """)
    
    return


@app.cell
def wallet_classification_data(pipeline_artifacts, pd):
    """Extract wallet classification data from artifacts.
    
    Requirements: 12.5, 14.3
    """
    wallet_classifications_df = None
    
    if pipeline_artifacts is None:
        return (wallet_classifications_df,)
    
    wallet_data = pipeline_artifacts.artifacts.get("wallet_classifications")
    
    if wallet_data is None:
        return (wallet_classifications_df,)
    
    # Handle different data formats
    if isinstance(wallet_data, pd.DataFrame):
        wallet_classifications_df = wallet_data
    elif isinstance(wallet_data, dict):
        if "address" in wallet_data and "behavior_class" in wallet_data:
            wallet_classifications_df = pd.DataFrame(wallet_data)
        elif "classifications" in wallet_data:
            wallet_classifications_df = pd.DataFrame(wallet_data["classifications"])
    
    return (wallet_classifications_df,)


@app.cell
def wallet_classification_chart(mo, alt, pd, wallet_classifications_df):
    """Create wallet behavior classification breakdown chart.
    
    Requirements: 12.5, 14.3
    Task: 15.2 Create ML prediction visualization cells
    """
    if wallet_classifications_df is None or wallet_classifications_df.empty:
        return (None,)
    
    # Find class column
    class_col = None
    for col in ["behavior_class", "class", "classification", "wallet_class"]:
        if col in wallet_classifications_df.columns:
            class_col = col
            break
    
    if class_col is None:
        return (None,)
    
    # Calculate class distribution
    class_counts = wallet_classifications_df[class_col].value_counts().reset_index()
    class_counts.columns = ["behavior_class", "count"]
    class_counts["percentage"] = class_counts["count"] / class_counts["count"].sum() * 100
    
    # Define colors for each class
    class_colors = {
        "trader": "#E45756",    # Red
        "holder": "#4C78A8",    # Blue
        "whale": "#F58518",     # Orange
        "retail": "#72B7B2",    # Teal
    }
    
    # Create bar chart
    wallet_chart = alt.Chart(class_counts).mark_bar().encode(
        x=alt.X(
            "behavior_class:N",
            title="Wallet Behavior Class",
            sort=["trader", "holder", "whale", "retail"],
        ),
        y=alt.Y("count:Q", title="Number of Wallets"),
        color=alt.Color(
            "behavior_class:N",
            scale=alt.Scale(
                domain=list(class_colors.keys()),
                range=list(class_colors.values()),
            ),
            legend=None,
        ),
        tooltip=[
            alt.Tooltip("behavior_class:N", title="Class"),
            alt.Tooltip("count:Q", title="Count", format=","),
            alt.Tooltip("percentage:Q", title="Percentage", format=".1f"),
        ]
    ).properties(
        title="Wallet Behavior Classification Distribution",
        width=400,
        height=300,
    )
    
    mo.md("#### Wallet Behavior Classification")
    return (wallet_chart,)


@app.cell
def display_wallet_classification_chart(mo, wallet_classifications_df, wallet_chart):
    """Display the wallet classification chart."""
    if wallet_classifications_df is None or wallet_chart is None:
        return
    
    try:
        return mo.ui.altair_chart(wallet_chart)
    except Exception:
        return wallet_chart


@app.cell
def wallet_classification_summary(mo, wallet_classifications_df):
    """Display wallet classification summary with confidence.
    
    Requirements: 12.5, 14.3
    """
    if wallet_classifications_df is None or wallet_classifications_df.empty:
        return
    
    # Find class and confidence columns
    class_col = None
    for col in ["behavior_class", "class", "classification", "wallet_class"]:
        if col in wallet_classifications_df.columns:
            class_col = col
            break
    
    conf_col = None
    for col in ["confidence", "probability", "score"]:
        if col in wallet_classifications_df.columns:
            conf_col = col
            break
    
    if class_col is None:
        return
    
    # Calculate statistics
    total_wallets = len(wallet_classifications_df)
    class_counts = wallet_classifications_df[class_col].value_counts()
    
    # Build class breakdown table
    rows = []
    for cls in ["trader", "holder", "whale", "retail"]:
        count = class_counts.get(cls, 0)
        pct = count / total_wallets * 100 if total_wallets > 0 else 0
        rows.append(f"| {cls.title()} | {count:,} | {pct:.1f}% |")
    
    class_table = "\n".join(rows)
    
    # Confidence statistics
    confidence_section = ""
    if conf_col is not None:
        avg_conf = wallet_classifications_df[conf_col].mean()
        low_conf_count = (wallet_classifications_df[conf_col] < 0.6).sum()
        confidence_section = f"""
    
    #### Classification Confidence
    
    | Metric | Value |
    |--------|-------|
    | **Average Confidence** | {avg_conf:.3f} |
    | **Low Confidence (<0.6)** | {low_conf_count:,} ({low_conf_count/total_wallets*100:.1f}%) |
    """
    
    mo.md(f"""
    #### Wallet Classification Summary
    
    | Class | Count | Percentage |
    |-------|-------|------------|
    {class_table}
    | **Total** | **{total_wallets:,}** | **100.0%** |
    {confidence_section}
    """)
    
    return


@app.cell
def behavior_class_filter_ui(mo, wallet_classifications_df):
    """Create filter UI for filtering analysis by behavior class.
    
    Requirements: 12.5, 14.3
    Task: 15.2 Create ML prediction visualization cells
    """
    if wallet_classifications_df is None or wallet_classifications_df.empty:
        return (None,)
    
    # Find class column
    class_col = None
    for col in ["behavior_class", "class", "classification", "wallet_class"]:
        if col in wallet_classifications_df.columns:
            class_col = col
            break
    
    if class_col is None:
        return (None,)
    
    # Get unique classes
    classes = wallet_classifications_df[class_col].unique().tolist()
    
    # Create multiselect filter
    behavior_filter = mo.ui.multiselect(
        options=classes,
        value=classes,  # All selected by default
        label="Filter by Behavior Class",
    )
    
    mo.md(f"""
    #### Filter Analysis by Wallet Behavior
    
    Select wallet behavior classes to include in the analysis:
    
    {behavior_filter}
    """)
    
    return (behavior_filter,)


# =============================================================================
# Model Comparison UI (Task 15.3)
# =============================================================================


@app.cell
def model_comparison_header(mo, zenml_available):
    """Display model comparison section header.
    
    Requirements: 15.1, 15.2, 15.3
    Task: 15.3 Create model comparison UI
    """
    if not zenml_available:
        return
    
    mo.md("""
    ### ðŸ“ˆ Model Version Comparison
    
    Compare ML model versions and their performance metrics.
    """)
    
    return


@app.cell
def model_selector_ui(mo, zenml_available):
    """Create model selector for version comparison.
    
    Requirements: 15.1, 15.2, 15.3
    """
    if not zenml_available:
        return (None,)
    
    model_selector = mo.ui.dropdown(
        options=[
            "sov_predictor",
            "wallet_classifier",
        ],
        value="sov_predictor",
        label="Select Model",
    )
    
    return (model_selector,)


@app.cell
def load_model_versions_cell(mo, zenml_bridge, zenml_available, model_selector):
    """Load model versions from ZenML registry.
    
    Requirements: 15.1, 15.2, 15.3
    Task: 15.3 Create model comparison UI
    """
    model_versions = []
    
    if not zenml_available or zenml_bridge is None or model_selector is None:
        return (model_versions,)
    
    model_name = model_selector.value
    
    try:
        model_versions = zenml_bridge.get_model_versions(model_name)
    except Exception as e:
        mo.md(f"""
        âš ï¸ Failed to load model versions: {e}
        """)
    
    return (model_versions,)


@app.cell
def model_versions_table(mo, zenml_available, model_selector, model_versions):
    """Display table of model versions with metrics.
    
    Requirements: 15.1, 15.2, 15.3
    Task: 15.3 Create model comparison UI
    """
    if not zenml_available or model_selector is None:
        return
    
    model_name = model_selector.value
    
    if not model_versions:
        # Show mock data for demonstration
        mo.md(f"""
        #### Model Versions: {model_name}
        
        | Version | Created | Precision | Recall | F1 | AUC | Status |
        |---------|---------|-----------|--------|-----|-----|--------|
        | v3 | 2024-12-10 | 0.85 | 0.82 | 0.83 | 0.91 | ðŸŸ¢ Production |
        | v2 | 2024-12-03 | 0.83 | 0.80 | 0.81 | 0.89 | âšª Archived |
        | v1 | 2024-11-26 | 0.78 | 0.75 | 0.76 | 0.85 | âšª Archived |
        
        > â„¹ï¸ Showing mock data. Connect to ZenML to see actual model versions.
        """)
        return
    
    # Build table rows
    rows = []
    for v in model_versions:
        metrics = v.get("metrics", {})
        precision = metrics.get("precision", "N/A")
        recall = metrics.get("recall", "N/A")
        f1 = metrics.get("f1", "N/A")
        auc = metrics.get("auc", "N/A")
        
        # Format metrics
        if isinstance(precision, (int, float)):
            precision = f"{precision:.2f}"
        if isinstance(recall, (int, float)):
            recall = f"{recall:.2f}"
        if isinstance(f1, (int, float)):
            f1 = f"{f1:.2f}"
        if isinstance(auc, (int, float)):
            auc = f"{auc:.2f}"
        
        # Status indicator
        is_prod = v.get("is_production", False)
        status = "ðŸŸ¢ Production" if is_prod else "âšª Archived"
        
        created = v.get("created", "N/A")
        if created and created != "N/A":
            created = created[:10]  # Just the date part
        
        rows.append(
            f"| {v.get('version', 'N/A')} | {created} | "
            f"{precision} | {recall} | {f1} | {auc} | {status} |"
        )
    
    table_rows = "\n".join(rows)
    
    mo.md(f"""
    #### Model Versions: {model_name}
    
    | Version | Created | Precision | Recall | F1 | AUC | Status |
    |---------|---------|-----------|--------|-----|-----|--------|
    {table_rows}
    """)
    
    return


@app.cell
def model_promotion_ui(mo, zenml_available, model_versions):
    """Create model promotion controls.
    
    Requirements: 15.1, 15.2, 15.3
    Task: 15.3 Create model comparison UI
    """
    if not zenml_available:
        return (None, None)
    
    # Get non-production versions for promotion
    promotable_versions = []
    if model_versions:
        promotable_versions = [
            v.get("version") 
            for v in model_versions 
            if not v.get("is_production", False) and v.get("version")
        ]
    
    if not promotable_versions:
        # Use mock versions for demonstration
        promotable_versions = ["v2", "v1"]
    
    version_selector = mo.ui.dropdown(
        options=promotable_versions,
        value=promotable_versions[0] if promotable_versions else None,
        label="Select Version to Promote",
    )
    
    promote_button = mo.ui.button(
        label="â¬†ï¸ Promote to Production",
        kind="warn",
    )
    
    return version_selector, promote_button


@app.cell
def display_promotion_controls(
    mo,
    zenml_available,
    version_selector,
    promote_button,
):
    """Display the model promotion controls."""
    if not zenml_available or version_selector is None:
        return
    
    mo.md("""
    #### Promote Model Version
    
    Select a model version to promote to production:
    """)
    
    mo.hstack([
        version_selector,
        promote_button,
    ])
    
    return


@app.cell
def handle_model_promotion(
    mo,
    zenml_bridge,
    zenml_available,
    model_selector,
    version_selector,
    promote_button,
):
    """Handle model promotion action.
    
    Requirements: 15.3
    """
    if not zenml_available or zenml_bridge is None:
        return
    
    if promote_button is None or not promote_button.value:
        return
    
    if version_selector is None or version_selector.value is None:
        mo.md("âš ï¸ Please select a version to promote.")
        return
    
    model_name = model_selector.value if model_selector else "sov_predictor"
    version = version_selector.value
    
    try:
        success = zenml_bridge.promote_model(model_name, version)
        
        if success:
            mo.md(f"""
            âœ… **Model promoted successfully!**
            
            Model `{model_name}` version `{version}` is now the production model.
            
            Refresh the page to see updated model status.
            """)
        else:
            mo.md(f"""
            âŒ **Failed to promote model.**
            
            Could not promote `{model_name}` version `{version}`.
            """)
            
    except Exception as e:
        mo.md(f"""
        âŒ **Error promoting model:** {e}
        """)
    
    return


@app.cell
def model_metrics_trend_chart(mo, alt, pd, model_versions):
    """Create model metrics trend chart.
    
    Requirements: 15.2
    Task: 15.3 Create model comparison UI
    """
    if not model_versions:
        # Use mock data for demonstration
        mock_data = [
            {"version": "v1", "f1": 0.76, "auc": 0.85},
            {"version": "v2", "f1": 0.81, "auc": 0.89},
            {"version": "v3", "f1": 0.83, "auc": 0.91},
        ]
        chart_df = pd.DataFrame(mock_data)
    else:
        # Extract metrics from versions
        chart_data = []
        for v in model_versions:
            metrics = v.get("metrics", {})
            if metrics:
                chart_data.append({
                    "version": v.get("version", "unknown"),
                    "f1": metrics.get("f1", 0),
                    "auc": metrics.get("auc", 0),
                })
        
        if not chart_data:
            return (None,)
        
        chart_df = pd.DataFrame(chart_data)
    
    # Melt for multi-line chart
    chart_df_melted = chart_df.melt(
        id_vars=["version"],
        value_vars=["f1", "auc"],
        var_name="metric",
        value_name="value",
    )
    
    # Create line chart
    metrics_chart = alt.Chart(chart_df_melted).mark_line(point=True).encode(
        x=alt.X("version:N", title="Model Version"),
        y=alt.Y("value:Q", title="Score", scale=alt.Scale(domain=[0, 1])),
        color=alt.Color(
            "metric:N",
            scale=alt.Scale(
                domain=["f1", "auc"],
                range=["#4C78A8", "#F58518"],
            ),
            legend=alt.Legend(title="Metric"),
        ),
        tooltip=[
            alt.Tooltip("version:N", title="Version"),
            alt.Tooltip("metric:N", title="Metric"),
            alt.Tooltip("value:Q", title="Score", format=".3f"),
        ]
    ).properties(
        title="Model Performance Trend",
        width=400,
        height=250,
    )
    
    mo.md("#### Model Performance Trend")
    return (metrics_chart,)


@app.cell
def display_metrics_trend_chart(mo, metrics_chart):
    """Display the model metrics trend chart."""
    if metrics_chart is None:
        return
    
    try:
        return mo.ui.altair_chart(metrics_chart)
    except Exception:
        return metrics_chart


# =============================================================================
# Conclusions and Summary
# =============================================================================


@app.cell
def conclusions_analysis_cell(
    loaded_data,
    activity_breakdown,
    holder_metrics,
    chain_metrics,
    calculate_confidence,
    generate_conclusions,
    get_data_quality_warnings,
):
    """Calculate confidence and generate conclusions."""
    confidence_metrics = None
    conclusions = None
    warnings = None

    if loaded_data is not None:
        # Calculate confidence
        confidence_metrics = calculate_confidence(loaded_data.transactions_df)

        # Generate conclusions if we have all the analysis results
        if activity_breakdown and holder_metrics and chain_metrics:
            conclusions = generate_conclusions(
                activity_breakdown,
                holder_metrics,
                chain_metrics,
                confidence_metrics,
                loaded_data.errors,
            )

        # Get data quality warnings
        warnings = get_data_quality_warnings(
            loaded_data.errors,
            confidence_metrics,
        )

    return confidence_metrics, conclusions, warnings


@app.cell
def summary_panel_display(
    mo,
    loaded_data,
    confidence_metrics,
    conclusions,
    warnings,
    ConfidenceLevel,
):
    """Display summary panel with key findings and confidence indicators."""
    if loaded_data is None or confidence_metrics is None:
        return

    # Confidence level styling
    confidence_colors = {
        ConfidenceLevel.HIGH: "ðŸŸ¢",
        ConfidenceLevel.MEDIUM: "ðŸŸ¡",
        ConfidenceLevel.LOW: "ðŸ”´",
    }
    confidence_icon = confidence_colors.get(
        confidence_metrics.confidence_level, "âšª"
    )

    # Build confidence details
    confidence_details = f"""
    | Metric | Value |
    |--------|-------|
    | **Sample Size** | {confidence_metrics.sample_size:,} transactions |
    | **Field Completeness** | {confidence_metrics.field_completeness:.1%} |
    | **Chain Coverage** | {confidence_metrics.chains_with_data}/3 chains |
    | **Confidence Score** | {confidence_metrics.confidence_score:.3f} |
    | **Confidence Level** | {confidence_icon} {confidence_metrics.confidence_level.value.upper()} |
    """

    # Build conclusions section
    conclusions_section = ""
    if conclusions:
        conclusion_rows = []
        for c in conclusions:
            conf_icon = confidence_colors.get(c.confidence, "âšª")
            conclusion_rows.append(
                f"| {c.finding} | **{c.value}** | {conf_icon} | {c.explanation} |"
            )
        conclusions_table = "\n".join(conclusion_rows)
        conclusions_section = f"""
    ### Key Findings

    | Finding | Value | Confidence | Explanation |
    |---------|-------|------------|-------------|
    {conclusions_table}
    """

    # Build warnings section
    warnings_section = ""
    if warnings:
        warning_items = "\n".join([f"- âš ï¸ {w}" for w in warnings])
        warnings_section = f"""
    ### Data Quality Warnings

    {warning_items}
    """

    # Sample data indicator
    sample_indicator = ""
    if loaded_data.is_sample_data:
        sample_indicator = """
    > âš ï¸ **Note:** This analysis is based on synthetic sample data, not real blockchain data.
    > Results are for demonstration purposes only.
    """

    mo.md(f"""
    ## Summary & Conclusions

    {sample_indicator}

    ### Data Quality & Confidence

    {confidence_details}

    {conclusions_section}

    {warnings_section}
    """)

    return


@app.cell
def final_summary(
    mo,
    loaded_data,
    activity_breakdown,
    holder_metrics,
    confidence_metrics,
    ConfidenceLevel,
):
    """Display final summary answering the main question."""
    if (loaded_data is None or activity_breakdown is None or
            holder_metrics is None or confidence_metrics is None):
        return

    # Calculate overall transaction vs SoV ratio
    tx_count = activity_breakdown.counts.get("transaction", 0)
    sov_count = activity_breakdown.counts.get("store_of_value", 0)
    total = tx_count + sov_count

    if total > 0:
        tx_pct = tx_count / total * 100
        sov_pct = sov_count / total * 100

        if tx_pct > sov_pct:
            primary_use = "**Everyday Transactions**"
            ratio_desc = f"{tx_pct:.1f}% transactions vs {sov_pct:.1f}% store-of-value"
        else:
            primary_use = "**Store of Value**"
            ratio_desc = f"{sov_pct:.1f}% store-of-value vs {tx_pct:.1f}% transactions"
    else:
        primary_use = "Insufficient data"
        ratio_desc = "No transaction data available"

    # Holder perspective
    holder_sov_pct = holder_metrics.sov_percentage
    holder_active_pct = 100.0 - holder_sov_pct

    if holder_sov_pct > holder_active_pct:
        holder_primary = "**Store of Value**"
    else:
        holder_primary = "**Active Transacting**"

    # Confidence indicator
    confidence_colors = {
        ConfidenceLevel.HIGH: "ðŸŸ¢ High",
        ConfidenceLevel.MEDIUM: "ðŸŸ¡ Medium",
        ConfidenceLevel.LOW: "ðŸ”´ Low",
    }
    confidence_display = confidence_colors.get(
        confidence_metrics.confidence_level, "âšª Unknown"
    )

    mo.md(f"""
    ---

    ## ðŸ“Š Final Answer: How Are Stablecoins Being Used?

    ### By Transaction Activity

    Primary use: {primary_use}

    {ratio_desc}

    ### By Holder Behavior

    Primary pattern: {holder_primary}

    {holder_sov_pct:.1f}% of holders are classified as store-of-value,
    while {holder_active_pct:.1f}% are active transactors.

    ### Confidence Level

    {confidence_display} (score: {confidence_metrics.confidence_score:.3f})

    ---

    *Analysis complete. Scroll up to explore detailed breakdowns by stablecoin,
    chain, and time period.*
    """)

    return


if __name__ == "__main__":
    app.run()
